<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ko6: src/soft/kernel/kthread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55.png"/></td>
  <td id="projectalign">
   <div id="projectname">ko6
   </div>
   <div id="projectbrief">ko6 (prononce it &#39;kit-O-sys&#39; O is  the letter not the number) is a small operating system for educationnal purpose</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_8785740846211ac34fd04c61a1fdd888.html">soft</a></li><li class="navelem"><a class="el" href="dir_f1add7e60d3117fa5e9acdff1c3c9be3.html">kernel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">kthread.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="klibc_8h_source.html">kernel/klibc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="debug__on_8h_source.html">common/debug_on.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthread__s.html">thread_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structthread__s.html" title="thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...">thread_s</a> structure which contains all we need to define a thread the size of <a class="el" href="structthread__s.html" title="thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...">thread_s</a> struct is a multiple of a page and have to be aligned (on a page) thread_t structure is a pointer to a thread_t structure Be th as pointer to a struct <a class="el" href="structthread__s.html" title="thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...">thread_s</a> : thread_t th th is at the beginning of a page, (that is (th &amp; 0xFFF)==0) the top of kernel stack is (char *)th + n * PAGE_SIZE th is allocated with kmalloc(PAGE_SIZE) is thread_create_kernel() kstack_b is a pointer to the top of kernel stack, this field has to be the first field of the structure because, thus is is easy to get it  <a href="structthread__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a798e4073d613ca5ba9618e1b3253df14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a>&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#ac3a4a9518b8467436c8806b33319c327">EC_YELLOW</a></td></tr>
<tr class="memdesc:a798e4073d613ca5ba9618e1b3253df14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump all the threads that are in the scheduler.  <br /></td></tr>
<tr class="separator:a798e4073d613ca5ba9618e1b3253df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b8f01fd6c0f47ff3cbddaeba63bfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a>&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a7f3b5cb90e3ed4bd270548f6798a5f22">EC_WHITE</a></td></tr>
<tr class="separator:a649b8f01fd6c0f47ff3cbddaeba63bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ea78689ecce0b7264c02c7f8a9a54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#aed9ea78689ecce0b7264c02c7f8a9a54">G</a>&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a3873bd551b4de1a4694e47d91f6ecc3e">EC_GREEN</a></td></tr>
<tr class="separator:aed9ea78689ecce0b7264c02c7f8a9a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52037c938e3c1b126c6277da5ca689d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a52037c938e3c1b126c6277da5ca689d0">M</a>&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a178ccd64797a5ab82b860f82b0567b03">EC_MAGENTA</a></td></tr>
<tr class="separator:a52037c938e3c1b126c6277da5ca689d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396fecfabe3105afc15a61c209f910f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a396fecfabe3105afc15a61c209f910f0">O</a>&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a69a73e6aff76280fedcf578f570b5ef4">EC_ORANGE</a></td></tr>
<tr class="separator:a396fecfabe3105afc15a61c209f910f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af933676109efed7ab34cea71d748a517"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#af933676109efed7ab34cea71d748a517">S</a>&#160;&#160;&#160;<a class="el" href="kthread_8c.html#a52037c938e3c1b126c6277da5ca689d0">M</a> &quot;%s&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td></tr>
<tr class="separator:af933676109efed7ab34cea71d748a517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2748566f4c443ee77aa831e63dbb5ebe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>&#160;&#160;&#160;<a class="el" href="kthread_8c.html#aed9ea78689ecce0b7264c02c7f8a9a54">G</a> &quot;%p&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td></tr>
<tr class="separator:a2748566f4c443ee77aa831e63dbb5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af316c33cc298530f245e8b55330e86b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a>&#160;&#160;&#160;<a class="el" href="kthread_8c.html#a396fecfabe3105afc15a61c209f910f0">O</a> &quot;%d&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td></tr>
<tr class="separator:af316c33cc298530f245e8b55330e86b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ecc03b8319efabea835c1205c8fff4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast</a> (<a class="el" href="list_8h.html#a3b55f1cd33b93f9cc32dbe31f95e22ed">list_t</a> *root, <a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread)</td></tr>
<tr class="separator:a3ecc03b8319efabea835c1205c8fff4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b0f0a19a09db45e1689ff011f6109b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item</a> (<a class="el" href="list_8h.html#a3b55f1cd33b93f9cc32dbe31f95e22ed">list_t</a> *item)</td></tr>
<tr class="separator:a79b0f0a19a09db45e1689ff011f6109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd5d32174e1f6b8b4562b4066a8b06"><td class="memItemLeft" align="right" valign="top">unsigned long long *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a2bcd5d32174e1f6b8b4562b4066a8b06">thread_krandseed</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread)</td></tr>
<tr class="memdesc:a2bcd5d32174e1f6b8b4562b4066a8b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">return address of krandseed for the thread given this function is defined here, because it needs to access at the hidden thread struct  <br /></td></tr>
<tr class="separator:a2bcd5d32174e1f6b8b4562b4066a8b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eded78b19b3a81e9f88ff0d45bf8258"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a3eded78b19b3a81e9f88ff0d45bf8258">thread_errno</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread)</td></tr>
<tr class="memdesc:a3eded78b19b3a81e9f88ff0d45bf8258"><td class="mdescLeft">&#160;</td><td class="mdescRight">return address of errno for the thread given this function is defined here, because it needs to access at the hidden thread struct  <br /></td></tr>
<tr class="separator:a3eded78b19b3a81e9f88ff0d45bf8258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad094fddcf3208d43f3385ed2aa419c10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread_new)</td></tr>
<tr class="memdesc:ad094fddcf3208d43f3385ed2aa419c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new thread, in the scheduler The scheduler is a simple table of all the threads To insert a new thread, we need to find a place.  <br /></td></tr>
<tr class="separator:ad094fddcf3208d43f3385ed2aa419c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9600d6716f732f0ca9bac066fa6ed7c"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#ab9600d6716f732f0ca9bac066fa6ed7c">__attribute__</a> ((noinline))</td></tr>
<tr class="memdesc:ab9600d6716f732f0ca9bac066fa6ed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the next ThreadCurrentIdx to execute There are two loops. at the beginning, sched_elect() goes through the scheduler's thread table ONCE to find a READY thread. On success, it returns the new ThreadCurrentIdx In the second loop, if no READY thread has been found, then IRQs are enabled, and sched_elect() searches until it finds a READY thread Thus, if <a class="el" href="kthread_8c.html#affe2eebf6749bc36765d45ff48c926b1" title="Causes the current thread to give up the CPU in order to give it to another.">thread_yield()</a> is called by timer_isr(), the ThreadCurrent is necessarly READY and then, sched_elect() will never enable the IRQ (it is forbidden to do so). <b>attribute</b>((noinline)) is to see this function is trace debug.  <br /></td></tr>
<tr class="separator:ab9600d6716f732f0ca9bac066fa6ed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c9880ce2be11d3a2c217c383d256fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a> (void)</td></tr>
<tr class="memdesc:a79c9880ce2be11d3a2c217c383d256fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current thread for another, it can be unchanged if it is alone.  <br /></td></tr>
<tr class="separator:a79c9880ce2be11d3a2c217c383d256fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cfe68dc8f379c88d448172f997b09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a02cfe68dc8f379c88d448172f997b09e">sched_dump</a> (void)</td></tr>
<tr class="memdesc:a02cfe68dc8f379c88d448172f997b09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays on the console (tty0) all active threads, it is for debugging.  <br /></td></tr>
<tr class="separator:a02cfe68dc8f379c88d448172f997b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6382c52388aa3e432787e2b9b4671bb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb">thread_bootstrap</a> (void)</td></tr>
<tr class="memdesc:ab6382c52388aa3e432787e2b9b4671bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> function is the bootstrap of the thread. It means that it is the very first function we call when the <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> returns for the very first time. In fact, <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> ends with a "jr $31" as usual but when we create a thread, $31 is initialized with the <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> address. Thus, when we return from <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> the very first time, we enter in <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a>. The function <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> cannot have any argument, since <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> does not restore $4 to $7 registers (which are the registers of arguments). So, that is the <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> itself that will call the threat_start() function with the needed arguments, as we know what is the current thread, and we are able to find out what is the user function to call with which args. As the thread is just beginning to run, its state is now RUNNING  <br /></td></tr>
<tr class="separator:ab6382c52388aa3e432787e2b9b4671bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2525e99272c4db4198bcea374d717620"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a2525e99272c4db4198bcea374d717620">thread_create</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> *thread_p, int fun, int arg, int start)</td></tr>
<tr class="memdesc:a2525e99272c4db4198bcea374d717620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls by the kernel in order to implement the user <a class="el" href="kthread_8h.html#a227d30321d9dddb518fe5d116aa7d90b" title="Calls by the kernel in order to implement the user thread_create() syscall This function has the same...">thread_create()</a> syscall This function has the same arguments as <a class="el" href="kthread_8h.html#a227d30321d9dddb518fe5d116aa7d90b" title="Calls by the kernel in order to implement the user thread_create() syscall This function has the same...">thread_create()</a>, plus one which is the pointer to the function that will start the thread, there are two of those: one for the main thread (nammed _start defined in <a class="el" href="crt0_8c.html">crt0.c</a>) and one for the standard thread (nammed thread_start defined in thread.c). These two functions do not have the same type but it does not matter because we are converting to int.  <br /></td></tr>
<tr class="separator:a2525e99272c4db4198bcea374d717620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c63c8faef6c13da432a94800ad2acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a95c63c8faef6c13da432a94800ad2acb">thread_main_load</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread)</td></tr>
<tr class="memdesc:a95c63c8faef6c13da432a94800ad2acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">load the context of the <a class="el" href="barrier_2main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a> thread, only used by kinit  <br /></td></tr>
<tr class="separator:a95c63c8faef6c13da432a94800ad2acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe2eebf6749bc36765d45ff48c926b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#affe2eebf6749bc36765d45ff48c926b1">thread_yield</a> (void)</td></tr>
<tr class="memdesc:affe2eebf6749bc36765d45ff48c926b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current thread to give up the CPU in order to give it to another.  <br /></td></tr>
<tr class="separator:affe2eebf6749bc36765d45ff48c926b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b16adf05364471bae2840aa564329a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a19b16adf05364471bae2840aa564329a">thread_exit</a> (void *retval)</td></tr>
<tr class="memdesc:a19b16adf05364471bae2840aa564329a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the current thread, it never returns (see details in <a class="el" href="kthread_8c.html">kthread.c</a>)  <br /></td></tr>
<tr class="separator:a19b16adf05364471bae2840aa564329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e54fc344bbd735b027c03629927abb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a4e54fc344bbd735b027c03629927abb9">thread_join</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread_expected, void **retval)</td></tr>
<tr class="memdesc:a4e54fc344bbd735b027c03629927abb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread termination (see details in <a class="el" href="kthread_8c.html">kthread.c</a>)  <br /></td></tr>
<tr class="separator:a4e54fc344bbd735b027c03629927abb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0fd0ef94a8688f65d53216ae6c33e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait</a> (void)</td></tr>
<tr class="memdesc:a0c0fd0ef94a8688f65d53216ae6c33e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a>. In some cases, when <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called just before <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> has had time to put the current thread in the WAIT state (this is possible, since <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called by another thread running on another processor) then the current thread is already READY but <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> yields the processor anyway, so the current thread should lose the processor for a while, until the scheduler chooses it again.  <br /></td></tr>
<tr class="separator:a0c0fd0ef94a8688f65d53216ae6c33e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9196e88e8db0daa5b13544cfe62996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify</a> (<a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread)</td></tr>
<tr class="memdesc:acc9196e88e8db0daa5b13544cfe62996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a>. In some cases, when <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called just before <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> has had time to put the current thread in the WAIT state (this is possible, since <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called by another thread running on another processor) then the current thread is already READY but <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> yields the processor anyway, so the current thread should lose the processor for a while, until the scheduler chooses it again.  <br /></td></tr>
<tr class="separator:acc9196e88e8db0daa5b13544cfe62996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aea4c4ea36a124f36c5a513e838d95419"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a> [<a class="el" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>]</td></tr>
<tr class="separator:aea4c4ea36a124f36c5a513e838d95419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48ff9d5d8665f90c44ae6ad4acb5b6d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a></td></tr>
<tr class="separator:ae48ff9d5d8665f90c44ae6ad4acb5b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5431310f6068f6d1113c402eff5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a></td></tr>
<tr class="memdesc:a1da5431310f6068f6d1113c402eff5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointeur to the current RUNNING thread (only one per processor) TODO should be an array if there are several processor TODO add a variable to count the number of threads and check it when tbread_create.  <br /></td></tr>
<tr class="separator:a1da5431310f6068f6d1113c402eff5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af316c33cc298530f245e8b55330e86b5" name="af316c33cc298530f245e8b55330e86b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af316c33cc298530f245e8b55330e86b5">&#9670;&#160;</a></span>D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define D&#160;&#160;&#160;<a class="el" href="kthread_8c.html#a396fecfabe3105afc15a61c209f910f0">O</a> &quot;%d&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed9ea78689ecce0b7264c02c7f8a9a54" name="aed9ea78689ecce0b7264c02c7f8a9a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9ea78689ecce0b7264c02c7f8a9a54">&#9670;&#160;</a></span>G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a3873bd551b4de1a4694e47d91f6ecc3e">EC_GREEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52037c938e3c1b126c6277da5ca689d0" name="a52037c938e3c1b126c6277da5ca689d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52037c938e3c1b126c6277da5ca689d0">&#9670;&#160;</a></span>M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a178ccd64797a5ab82b860f82b0567b03">EC_MAGENTA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a396fecfabe3105afc15a61c209f910f0" name="a396fecfabe3105afc15a61c209f910f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396fecfabe3105afc15a61c209f910f0">&#9670;&#160;</a></span>O</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define O&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a69a73e6aff76280fedcf578f570b5ef4">EC_ORANGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2748566f4c443ee77aa831e63dbb5ebe" name="a2748566f4c443ee77aa831e63dbb5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2748566f4c443ee77aa831e63dbb5ebe">&#9670;&#160;</a></span>P</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P&#160;&#160;&#160;<a class="el" href="kthread_8c.html#aed9ea78689ecce0b7264c02c7f8a9a54">G</a> &quot;%p&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af933676109efed7ab34cea71d748a517" name="af933676109efed7ab34cea71d748a517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af933676109efed7ab34cea71d748a517">&#9670;&#160;</a></span>S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S&#160;&#160;&#160;<a class="el" href="kthread_8c.html#a52037c938e3c1b126c6277da5ca689d0">M</a> &quot;%s&quot; <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a649b8f01fd6c0f47ff3cbddaeba63bfb" name="a649b8f01fd6c0f47ff3cbddaeba63bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649b8f01fd6c0f47ff3cbddaeba63bfb">&#9670;&#160;</a></span>W</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define W&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#a7f3b5cb90e3ed4bd270548f6798a5f22">EC_WHITE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a798e4073d613ca5ba9618e1b3253df14" name="a798e4073d613ca5ba9618e1b3253df14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798e4073d613ca5ba9618e1b3253df14">&#9670;&#160;</a></span>Y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Y&#160;&#160;&#160;<a class="el" href="esc__code_8h.html#ac3a4a9518b8467436c8806b33319c327">EC_YELLOW</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump all the threads that are in the scheduler. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab9600d6716f732f0ca9bac066fa6ed7c" name="ab9600d6716f732f0ca9bac066fa6ed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9600d6716f732f0ca9bac066fa6ed7c">&#9670;&#160;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the next ThreadCurrentIdx to execute There are two loops. at the beginning, sched_elect() goes through the scheduler's thread table ONCE to find a READY thread. On success, it returns the new ThreadCurrentIdx In the second loop, if no READY thread has been found, then IRQs are enabled, and sched_elect() searches until it finds a READY thread Thus, if <a class="el" href="kthread_8c.html#affe2eebf6749bc36765d45ff48c926b1" title="Causes the current thread to give up the CPU in order to give it to another.">thread_yield()</a> is called by timer_isr(), the ThreadCurrent is necessarly READY and then, sched_elect() will never enable the IRQ (it is forbidden to do so). <b>attribute</b>((noinline)) is to see this function is trace debug. </p>
<dl class="section return"><dt>Returns</dt><dd>the next thread number to execute, it could be unchanged if there is not any else </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  123</span>{</div>
<div class="line"><span class="lineno">  124</span>    <span class="comment">// ---- First search for a READY state with IRQ disabled</span></div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordtype">int</span> th, thmax;</div>
<div class="line"><span class="lineno">  127</span>    th = thmax = (<a class="code hl_variable" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a> + 1) % <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>;       <span class="comment">// start with the current thread + 1</span></div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">  129</span>        <span class="keywordflow">if</span> ( <a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th] &amp;&amp;</div>
<div class="line"><span class="lineno">  130</span>            (<a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th]-&gt;state == <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>)) {     <span class="comment">// thread READY found</span></div>
<div class="line"><span class="lineno">  131</span>            <span class="keywordflow">return</span> th;                                      <span class="comment">// return the chosen one</span></div>
<div class="line"><span class="lineno">  132</span>        }</div>
<div class="line"><span class="lineno">  133</span>        th = (th+1) % <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>;                           <span class="comment">// go to the next (circular course)</span></div>
<div class="line"><span class="lineno">  134</span>    } <span class="keywordflow">while</span> (th != thmax);                                  <span class="comment">// Only one loop</span></div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span>    <span class="comment">// ---- Then if there is no READY thread then wait for it with IRQ enabled</span></div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>    <a class="code hl_function" href="cpu_2irq_8h.html#a0a004f8aa16635895a42e0667f26c420">irq_enable</a>();</div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">while</span> ( (<a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th] == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) || (<a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th]-&gt;state != <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>)) {</div>
<div class="line"><span class="lineno">  140</span>        th = (th+1) % <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>;                           <span class="comment">// we search as long as we do not found</span></div>
<div class="line"><span class="lineno">  141</span>    }</div>
<div class="line"><span class="lineno">  142</span>    <a class="code hl_function" href="cpu_2irq_8h.html#ae2c42997fe73f8d5cc4890c66955b21d">irq_disable</a>();</div>
<div class="line"><span class="lineno">  143</span>    <span class="keywordflow">return</span> th;                                              <span class="comment">// return the chosen one</span></div>
<div class="line"><span class="lineno">  144</span>}</div>
<div class="ttc" id="acpu_2irq_8h_html_a0a004f8aa16635895a42e0667f26c420"><div class="ttname"><a href="cpu_2irq_8h.html#a0a004f8aa16635895a42e0667f26c420">irq_enable</a></div><div class="ttdeci">void irq_enable(void)</div><div class="ttdoc">enable irq (do not change the MIPS mode thus stay in kernel mode)</div></div>
<div class="ttc" id="acpu_2irq_8h_html_ae2c42997fe73f8d5cc4890c66955b21d"><div class="ttname"><a href="cpu_2irq_8h.html#ae2c42997fe73f8d5cc4890c66955b21d">irq_disable</a></div><div class="ttdeci">unsigned irq_disable(void)</div><div class="ttdoc">disable irq</div></div>
<div class="ttc" id="akfs_8c_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> kfs.c:24</div></div>
<div class="ttc" id="akthread_8c_html_ae48ff9d5d8665f90c44ae6ad4acb5b6d"><div class="ttname"><a href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a></div><div class="ttdeci">static int ThreadCurrentIdx</div><div class="ttdef"><b>Definition:</b> kthread.c:53</div></div>
<div class="ttc" id="akthread_8c_html_aea4c4ea36a124f36c5a513e838d95419"><div class="ttname"><a href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a></div><div class="ttdeci">static thread_t ThreadTab[THREAD_MAX]</div><div class="ttdef"><b>Definition:</b> kthread.c:52</div></div>
<div class="ttc" id="akthread_8h_html_a1887e40b17ecfda05b4a398375d527fb"><div class="ttname"><a href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a></div><div class="ttdeci">#define TH_STATE_READY</div><div class="ttdef"><b>Definition:</b> kthread.h:32</div></div>
<div class="ttc" id="akthread_8h_html_a425c1da89e5866d87fc20a624da7cbec"><div class="ttname"><a href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a></div><div class="ttdeci">#define THREAD_MAX</div><div class="ttdef"><b>Definition:</b> kthread.h:23</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="cpu_2irq_8h.html#ae2c42997fe73f8d5cc4890c66955b21d">irq_disable()</a>, <a class="el" href="cpu_2irq_8h.html#a0a004f8aa16635895a42e0667f26c420">irq_enable()</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, <a class="el" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>, <a class="el" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a>, and <a class="el" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>.</p>

</div>
</div>
<a id="a02cfe68dc8f379c88d448172f997b09e" name="a02cfe68dc8f379c88d448172f997b09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cfe68dc8f379c88d448172f997b09e">&#9670;&#160;</a></span>sched_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sched_dump </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays on the console (tty0) all active threads, it is for debugging. </p>
<div class="fragment"><div class="line"><span class="lineno">  175</span>{</div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordtype">char</span> *state_name[16] = {</div>
<div class="line"><span class="lineno">  177</span>        [<a class="code hl_define" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>] = <span class="stringliteral">&quot;RUNNING&quot;</span>,</div>
<div class="line"><span class="lineno">  178</span>        [<a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>] = <span class="stringliteral">&quot;READY&quot;</span>,</div>
<div class="line"><span class="lineno">  179</span>        [<a class="code hl_define" href="kthread_8h.html#aeae3234bde1a15d5c671a41286949bc5">TH_STATE_DEAD</a>] = <span class="stringliteral">&quot;DEAD&quot;</span>,</div>
<div class="line"><span class="lineno">  180</span>        [<a class="code hl_define" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>] = <span class="stringliteral">&quot;WAIT&quot;</span>,</div>
<div class="line"><span class="lineno">  181</span>        [<a class="code hl_define" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>] = <span class="stringliteral">&quot;ZOMBIE&quot;</span>,</div>
<div class="line"><span class="lineno">  182</span>    };</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>    <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<a class="code hl_define" href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a><span class="stringliteral">&quot;-------------------------- DUMP ALL THREADS ---------------------------\n&quot;</span>);</div>
<div class="line"><span class="lineno">  185</span>    <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<a class="code hl_define" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a><span class="stringliteral">&quot;thread current (&quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;) : &quot;</span><a class="code hl_define" href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a><span class="stringliteral">&quot;\n&quot;</span>, <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, <a class="code hl_variable" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a>);</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> th = 0; th &lt; <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>; th++) {</div>
<div class="line"><span class="lineno">  187</span>        <a class="code hl_struct" href="structthread__s.html">thread_t</a> thread = <a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th];</div>
<div class="line"><span class="lineno">  188</span>        <span class="keywordflow">if</span> (thread) {</div>
<div class="line"><span class="lineno">  189</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<a class="code hl_define" href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a><span class="stringliteral">&quot;----------------------------------------------------------------------- &quot;</span>);</div>
<div class="line"><span class="lineno">  190</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<a class="code hl_define" href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a><span class="stringliteral">&quot;\n&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#ad1ed1d821f595f5a7c1d68f09ba36bf5">tid</a>);</div>
<div class="line"><span class="lineno">  191</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;[&quot;</span><a class="code hl_define" href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a><span class="stringliteral">&quot;] thread: &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>,  <a class="code hl_function" href="cpuregs_8h.html#a6f8d66e44afa86c6e39901b0dbbf709e">clock</a> (), thread);</div>
<div class="line"><span class="lineno">  192</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   errmsg: &quot;</span><a class="code hl_define" href="kthread_8c.html#af933676109efed7ab34cea71d748a517">S</a><span class="stringliteral">&quot;\n&quot;</span>, <a class="code hl_variable" href="errno_8c.html#a752b191220a1b00e3d70f9359a660f0f">errno_mess</a>[<span class="comment">/*errno+*/</span>1]);</div>
<div class="line"><span class="lineno">  193</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot; - state:     &quot;</span><a class="code hl_define" href="kthread_8c.html#af933676109efed7ab34cea71d748a517">S</a><span class="stringliteral">&quot;\t&quot;</span>, state_name[thread-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a>]);</div>
<div class="line"><span class="lineno">  194</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   wait.next: &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">wait</a>.<a class="code hl_variable" href="structlist__s.html#a3fe402fa883820f9823c1e47246f9880">next</a>);</div>
<div class="line"><span class="lineno">  195</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   wait.prev: &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\n&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">wait</a>.<a class="code hl_variable" href="structlist__s.html#af220645f4ec4f64798bc6d8ea9765185">prev</a>);</div>
<div class="line"><span class="lineno">  196</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot; - retval:    &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">retval</a>);</div>
<div class="line"><span class="lineno">  197</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   join:      &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">join</a>);</div>
<div class="line"><span class="lineno">  198</span>           <span class="comment">//kprintf (&quot;   errno:     &quot;P&quot;\n&quot;, errno);</span></div>
<div class="line"><span class="lineno">  199</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   errno:     &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\n&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>-&gt;<a class="code hl_variable" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">tls_errno</a>);</div>
<div class="line"><span class="lineno">  200</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot; - start:     &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">start</a>);</div>
<div class="line"><span class="lineno">  201</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   function:  &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">fun</a>);</div>
<div class="line"><span class="lineno">  202</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;   arg:       &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;\n&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">arg</a>);</div>
<div class="line"><span class="lineno">  203</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot; - ustack_b:  &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot; (&quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;)\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">ustack_b</a>, *(<span class="keywordtype">int</span>*)thread-&gt;<a class="code hl_variable" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">ustack_b</a>);</div>
<div class="line"><span class="lineno">  204</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (  <span class="stringliteral">&quot; ustack_e:  &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot; (&quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;)\n&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">ustack_e</a>, *(<span class="keywordtype">int</span>*)thread-&gt;<a class="code hl_variable" href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">ustack_e</a>);</div>
<div class="line"><span class="lineno">  205</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot; - kstack_b:  &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot; (&quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;)\t&quot;</span>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">kstack_b</a>, *(<span class="keywordtype">int</span>*)thread-&gt;<a class="code hl_variable" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">kstack_b</a>);</div>
<div class="line"><span class="lineno">  206</span>           <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (  <span class="stringliteral">&quot; kstack_e:  &quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot; (&quot;</span><a class="code hl_define" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a><span class="stringliteral">&quot;)\n&quot;</span>, &amp;thread-&gt;<a class="code hl_variable" href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">kstack</a>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">kstack</a>[0]);</div>
<div class="line"><span class="lineno">  207</span><span class="comment">/*</span></div>
<div class="line"><span class="lineno">  208</span><span class="comment">           kprintf (&quot; - context:&quot;);</span></div>
<div class="line"><span class="lineno">  209</span><span class="comment">           kprintf (&quot;   S0: &quot;P,          thread-&gt;context[TH_CONTEXT_S0]);</span></div>
<div class="line"><span class="lineno">  210</span><span class="comment">           kprintf (&quot;   S1: &quot;P,          thread-&gt;context[TH_CONTEXT_S1]);</span></div>
<div class="line"><span class="lineno">  211</span><span class="comment">           kprintf (&quot;   S2: &quot;P,          thread-&gt;context[TH_CONTEXT_S2]);</span></div>
<div class="line"><span class="lineno">  212</span><span class="comment">           kprintf (&quot;   S3: &quot;P&quot;\n\t   &quot;, thread-&gt;context[TH_CONTEXT_S3]);</span></div>
<div class="line"><span class="lineno">  213</span><span class="comment">           kprintf (&quot;   S4: &quot;P,          thread-&gt;context[TH_CONTEXT_S4]);</span></div>
<div class="line"><span class="lineno">  214</span><span class="comment">           kprintf (&quot;   S5: &quot;P,          thread-&gt;context[TH_CONTEXT_S5]);</span></div>
<div class="line"><span class="lineno">  215</span><span class="comment">           kprintf (&quot;   S6: &quot;P,          thread-&gt;context[TH_CONTEXT_S6]);</span></div>
<div class="line"><span class="lineno">  216</span><span class="comment">           kprintf (&quot;   S7: &quot;P&quot;\n\t   &quot;, thread-&gt;context[TH_CONTEXT_S7]);</span></div>
<div class="line"><span class="lineno">  217</span><span class="comment">           kprintf (&quot;   S8: &quot;P,          thread-&gt;context[TH_CONTEXT_S8]);</span></div>
<div class="line"><span class="lineno">  218</span><span class="comment">           kprintf (&quot;   SR: &quot;P,          thread-&gt;context[TH_CONTEXT_SR]);</span></div>
<div class="line"><span class="lineno">  219</span><span class="comment">           kprintf (&quot;   RA: &quot;P,          thread-&gt;context[TH_CONTEXT_RA]);</span></div>
<div class="line"><span class="lineno">  220</span><span class="comment">           kprintf (&quot;   SP: &quot;P&quot;\n&quot;,      thread-&gt;context[TH_CONTEXT_SP]);</span></div>
<div class="line"><span class="lineno">  221</span><span class="comment">*/</span></div>
<div class="line"><span class="lineno">  222</span>        }</div>
<div class="line"><span class="lineno">  223</span>    }</div>
<div class="line"><span class="lineno">  224</span>    <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<a class="code hl_define" href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a><span class="stringliteral">&quot;------------------------ END DUMP ALL THREADS -------------------------\n&quot;</span>);</div>
<div class="line"><span class="lineno">  225</span>}</div>
<div class="ttc" id="acpuregs_8h_html_a6f8d66e44afa86c6e39901b0dbbf709e"><div class="ttname"><a href="cpuregs_8h.html#a6f8d66e44afa86c6e39901b0dbbf709e">clock</a></div><div class="ttdeci">unsigned clock(void)</div><div class="ttdoc">clock cycle counter</div><div class="ttdef"><b>Definition:</b> libc.c:47</div></div>
<div class="ttc" id="aerrno_8c_html_a752b191220a1b00e3d70f9359a660f0f"><div class="ttname"><a href="errno_8c.html#a752b191220a1b00e3d70f9359a660f0f">errno_mess</a></div><div class="ttdeci">char * errno_mess[]</div><div class="ttdoc">errno is a thread local variable, that means it is like a global variable (thus accessible anywhere) ...</div><div class="ttdef"><b>Definition:</b> errno.c:18</div></div>
<div class="ttc" id="aklibc_8c_html_ac4ae3bb8e59735d2b772e77186b52228"><div class="ttname"><a href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a></div><div class="ttdeci">int kprintf(char *fmt,...)</div><div class="ttdoc">print a formated string to the TTY0 this a simplified version which handles only: c,...</div><div class="ttdef"><b>Definition:</b> klibc.c:37</div></div>
<div class="ttc" id="akthread_8c_html_a1da5431310f6068f6d1113c402eff5f8"><div class="ttname"><a href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a></div><div class="ttdeci">thread_t ThreadCurrent</div><div class="ttdoc">Pointeur to the current RUNNING thread (only one per processor) TODO should be an array if there are ...</div><div class="ttdef"><b>Definition:</b> kthread.c:54</div></div>
<div class="ttc" id="akthread_8c_html_a2748566f4c443ee77aa831e63dbb5ebe"><div class="ttname"><a href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a></div><div class="ttdeci">#define P</div><div class="ttdef"><b>Definition:</b> kthread.c:172</div></div>
<div class="ttc" id="akthread_8c_html_a649b8f01fd6c0f47ff3cbddaeba63bfb"><div class="ttname"><a href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a></div><div class="ttdeci">#define W</div><div class="ttdef"><b>Definition:</b> kthread.c:167</div></div>
<div class="ttc" id="akthread_8c_html_a798e4073d613ca5ba9618e1b3253df14"><div class="ttname"><a href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a></div><div class="ttdeci">#define Y</div><div class="ttdoc">Dump all the threads that are in the scheduler.</div><div class="ttdef"><b>Definition:</b> kthread.c:166</div></div>
<div class="ttc" id="akthread_8c_html_af316c33cc298530f245e8b55330e86b5"><div class="ttname"><a href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a></div><div class="ttdeci">#define D</div><div class="ttdef"><b>Definition:</b> kthread.c:173</div></div>
<div class="ttc" id="akthread_8c_html_af933676109efed7ab34cea71d748a517"><div class="ttname"><a href="kthread_8c.html#af933676109efed7ab34cea71d748a517">S</a></div><div class="ttdeci">#define S</div><div class="ttdef"><b>Definition:</b> kthread.c:171</div></div>
<div class="ttc" id="akthread_8h_html_a55287315008b2fea47936dc065bbabb7"><div class="ttname"><a href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a></div><div class="ttdeci">#define TH_STATE_ZOMBIE</div><div class="ttdef"><b>Definition:</b> kthread.h:35</div></div>
<div class="ttc" id="akthread_8h_html_a75c1c2f7da0a338d818a2950b582b74a"><div class="ttname"><a href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a></div><div class="ttdeci">#define TH_STATE_WAIT</div><div class="ttdef"><b>Definition:</b> kthread.h:34</div></div>
<div class="ttc" id="akthread_8h_html_a83c4c9d919043cd3b5bac98b7250d506"><div class="ttname"><a href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a></div><div class="ttdeci">#define TH_STATE_RUNNING</div><div class="ttdef"><b>Definition:</b> kthread.h:31</div></div>
<div class="ttc" id="akthread_8h_html_aeae3234bde1a15d5c671a41286949bc5"><div class="ttname"><a href="kthread_8h.html#aeae3234bde1a15d5c671a41286949bc5">TH_STATE_DEAD</a></div><div class="ttdeci">#define TH_STATE_DEAD</div><div class="ttdef"><b>Definition:</b> kthread.h:33</div></div>
<div class="ttc" id="astruct__tls__s_html_a2b0505d872f110754ab80cdfe94bf58e"><div class="ttname"><a href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">_tls_s::tls_errno</a></div><div class="ttdeci">int tls_errno</div><div class="ttdoc">syscall error number</div><div class="ttdef"><b>Definition:</b> usermem.h:71</div></div>
<div class="ttc" id="astructlist__s_html_a3fe402fa883820f9823c1e47246f9880"><div class="ttname"><a href="structlist__s.html#a3fe402fa883820f9823c1e47246f9880">list_s::next</a></div><div class="ttdeci">struct list_s * next</div><div class="ttdoc">toward another same type struct in a root or a item list</div><div class="ttdef"><b>Definition:</b> list.h:82</div></div>
<div class="ttc" id="astructlist__s_html_af220645f4ec4f64798bc6d8ea9765185"><div class="ttname"><a href="structlist__s.html#af220645f4ec4f64798bc6d8ea9765185">list_s::prev</a></div><div class="ttdeci">struct list_s * prev</div><div class="ttdoc">backward</div><div class="ttdef"><b>Definition:</b> list.h:83</div></div>
<div class="ttc" id="astructthread__s_html"><div class="ttname"><a href="structthread__s.html">thread_s</a></div><div class="ttdoc">thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...</div><div class="ttdef"><b>Definition:</b> kthread.c:33</div></div>
<div class="ttc" id="astructthread__s_html_a021e8a50ddb4a5978f18d6babfc4ea6e"><div class="ttname"><a href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">thread_s::ustack_e</a></div><div class="ttdeci">int ustack_e</div><div class="ttdoc">user stack end (thus the lowest addr)</div><div class="ttdef"><b>Definition:</b> kthread.c:36</div></div>
<div class="ttc" id="astructthread__s_html_a1159b3f03199aed705bf099f2eb33a92"><div class="ttname"><a href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">thread_s::kstack</a></div><div class="ttdeci">int kstack[1]</div><div class="ttdoc">lowest address of kernel stack of thread (with MAGIC_STACK)</div><div class="ttdef"><b>Definition:</b> kthread.c:49</div></div>
<div class="ttc" id="astructthread__s_html_a291769866cccb5d37937ef14cedc38bf"><div class="ttname"><a href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">thread_s::wait</a></div><div class="ttdeci">list_t wait</div><div class="ttdoc">list element to chain threads waiting for the same resource</div><div class="ttdef"><b>Definition:</b> kthread.c:37</div></div>
<div class="ttc" id="astructthread__s_html_a5cdab21069c6c184a86d024a0aa238aa"><div class="ttname"><a href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">thread_s::arg</a></div><div class="ttdeci">int arg</div><div class="ttdoc">thread argument (cast to int)</div><div class="ttdef"><b>Definition:</b> kthread.c:45</div></div>
<div class="ttc" id="astructthread__s_html_a63551d8e6d21a7370c5b3652cea282fc"><div class="ttname"><a href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">thread_s::start</a></div><div class="ttdeci">int start</div><div class="ttdoc">pointer to the function which calls fun(arg)</div><div class="ttdef"><b>Definition:</b> kthread.c:43</div></div>
<div class="ttc" id="astructthread__s_html_a6885e765fcfe5d2ad0e5a07c2df3ee69"><div class="ttname"><a href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">thread_s::kstack_b</a></div><div class="ttdeci">int kstack_b</div><div class="ttdoc">kernel stack beginning (the highest addr, outside the stack)</div><div class="ttdef"><b>Definition:</b> kthread.c:34</div></div>
<div class="ttc" id="astructthread__s_html_a7ad218d5b7c4b6bc9c4602e6b1a89815"><div class="ttname"><a href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a></div><div class="ttdeci">_tls_t * ptls</div><div class="ttdoc">ptr to current thread local storage (see common/usermem.h)</div><div class="ttdef"><b>Definition:</b> kthread.c:40</div></div>
<div class="ttc" id="astructthread__s_html_a84fafe08d8ef25fc4b5a8fb1e833619c"><div class="ttname"><a href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">thread_s::join</a></div><div class="ttdeci">thread_t join</div><div class="ttdoc">expected thread in case of thread_join()</div><div class="ttdef"><b>Definition:</b> kthread.c:42</div></div>
<div class="ttc" id="astructthread__s_html_a8d51270c2f7572479276f7629940c3ea"><div class="ttname"><a href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">thread_s::ustack_b</a></div><div class="ttdeci">int ustack_b</div><div class="ttdoc">user stack beginning (the highest address, outside the stack)</div><div class="ttdef"><b>Definition:</b> kthread.c:35</div></div>
<div class="ttc" id="astructthread__s_html_a9a97385576dda275389e95ef13168cfc"><div class="ttname"><a href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">thread_s::fun</a></div><div class="ttdeci">int fun</div><div class="ttdoc">pointer to the thread function (cast to int)</div><div class="ttdef"><b>Definition:</b> kthread.c:44</div></div>
<div class="ttc" id="astructthread__s_html_ab3fce89938b5156047553299f71a1370"><div class="ttname"><a href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a></div><div class="ttdeci">int state</div><div class="ttdoc">thread state from the scheduler point of view</div><div class="ttdef"><b>Definition:</b> kthread.c:39</div></div>
<div class="ttc" id="astructthread__s_html_ad1ed1d821f595f5a7c1d68f09ba36bf5"><div class="ttname"><a href="structthread__s.html#ad1ed1d821f595f5a7c1d68f09ba36bf5">thread_s::tid</a></div><div class="ttdeci">int tid</div><div class="ttdoc">thread identifer MUST BE PLACED JUST BEFORE CONTEXT (trace)</div><div class="ttdef"><b>Definition:</b> kthread.c:46</div></div>
<div class="ttc" id="astructthread__s_html_aeefa131a48c8c3c45e6c3c0819f21cd0"><div class="ttname"><a href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">thread_s::retval</a></div><div class="ttdeci">void * retval</div><div class="ttdoc">return value</div><div class="ttdef"><b>Definition:</b> kthread.c:41</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">thread_s::arg</a>, <a class="el" href="cpuregs_8h.html#a6f8d66e44afa86c6e39901b0dbbf709e">clock()</a>, <a class="el" href="kthread_8c.html#af316c33cc298530f245e8b55330e86b5">D</a>, <a class="el" href="errno_8c.html#a752b191220a1b00e3d70f9359a660f0f">errno_mess</a>, <a class="el" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">thread_s::fun</a>, <a class="el" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">thread_s::join</a>, <a class="el" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf()</a>, <a class="el" href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">thread_s::kstack</a>, <a class="el" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">thread_s::kstack_b</a>, <a class="el" href="structlist__s.html#a3fe402fa883820f9823c1e47246f9880">list_s::next</a>, <a class="el" href="kthread_8c.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>, <a class="el" href="structlist__s.html#af220645f4ec4f64798bc6d8ea9765185">list_s::prev</a>, <a class="el" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a>, <a class="el" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">thread_s::retval</a>, <a class="el" href="kthread_8c.html#af933676109efed7ab34cea71d748a517">S</a>, <a class="el" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">thread_s::start</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#aeae3234bde1a15d5c671a41286949bc5">TH_STATE_DEAD</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, <a class="el" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>, <a class="el" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>, <a class="el" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>, <a class="el" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, <a class="el" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a>, <a class="el" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>, <a class="el" href="structthread__s.html#ad1ed1d821f595f5a7c1d68f09ba36bf5">thread_s::tid</a>, <a class="el" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">_tls_s::tls_errno</a>, <a class="el" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">thread_s::ustack_b</a>, <a class="el" href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">thread_s::ustack_e</a>, <a class="el" href="kthread_8c.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a>, <a class="el" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">thread_s::wait</a>, and <a class="el" href="kthread_8c.html#a798e4073d613ca5ba9618e1b3253df14">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="mips_2kpanicc_8c.html#a065995e33e52287fdb635c739984fa4c">kdump()</a>.</p>

</div>
</div>
<a id="ad094fddcf3208d43f3385ed2aa419c10" name="ad094fddcf3208d43f3385ed2aa419c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad094fddcf3208d43f3385ed2aa419c10">&#9670;&#160;</a></span>sched_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sched_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new thread, in the scheduler The scheduler is a simple table of all the threads To insert a new thread, we need to find a place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_new</td><td>is the thread to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   97</span>{</div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordtype">int</span> tid = 0;</div>
<div class="line"><span class="lineno">   99</span>    <span class="keywordflow">while</span> ((tid &lt; <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>) &amp;&amp; (<a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[tid])) tid++;   <span class="comment">// look for an empty place</span></div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">if</span> (tid == <a class="code hl_define" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>) {                                <span class="comment">// if not found -&gt; exit(1);</span></div>
<div class="line"><span class="lineno">  101</span>        <a class="code hl_function" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf</a> (<span class="stringliteral">&quot;[%d] to many thread created (thread.h/THREAD_MAX\n)&quot;</span>, <a class="code hl_function" href="cpuregs_8h.html#a6f8d66e44afa86c6e39901b0dbbf709e">clock</a>());</div>
<div class="line"><span class="lineno">  102</span>        <a class="code hl_function" href="klibc_8c.html#a55e99c539cf7723ec15e856b7e0a8cee">exit</a>(1);</div>
<div class="line"><span class="lineno">  103</span>    }</div>
<div class="line"><span class="lineno">  104</span>    thread_new-&gt;<a class="code hl_variable" href="structthread__s.html#ad1ed1d821f595f5a7c1d68f09ba36bf5">tid</a> = tid;                                  <span class="comment">// set thread identifier</span></div>
<div class="line"><span class="lineno">  105</span>    <a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[tid] = thread_new;                            <span class="comment">// store the new thread</span></div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a> == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)                              <span class="comment">// first thread insertion</span></div>
<div class="line"><span class="lineno">  107</span>        <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a> = thread_new;</div>
<div class="line"><span class="lineno">  108</span>}</div>
<div class="ttc" id="aklibc_8c_html_a55e99c539cf7723ec15e856b7e0a8cee"><div class="ttname"><a href="klibc_8c.html#a55e99c539cf7723ec15e856b7e0a8cee">exit</a></div><div class="ttdeci">void exit(int status)</div><div class="ttdoc">exit the application, thus never returns</div><div class="ttdef"><b>Definition:</b> klibc.c:48</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="cpuregs_8h.html#a6f8d66e44afa86c6e39901b0dbbf709e">clock()</a>, <a class="el" href="klibc_8c.html#a55e99c539cf7723ec15e856b7e0a8cee">exit()</a>, <a class="el" href="klibc_8c.html#ac4ae3bb8e59735d2b772e77186b52228">kprintf()</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, <a class="el" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>, and <a class="el" href="structthread__s.html#ad1ed1d821f595f5a7c1d68f09ba36bf5">thread_s::tid</a>.</p>

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#a2525e99272c4db4198bcea374d717620">thread_create()</a>.</p>

</div>
</div>
<a id="a79c9880ce2be11d3a2c217c383d256fb" name="a79c9880ce2be11d3a2c217c383d256fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c9880ce2be11d3a2c217c383d256fb">&#9670;&#160;</a></span>sched_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sched_switch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the current thread for another, it can be unchanged if it is alone. </p>
<div class="fragment"><div class="line"><span class="lineno">  150</span>{</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordtype">int</span> th_next = sched_elect ();                           <span class="comment">// get a next ready thread</span></div>
<div class="line"><span class="lineno">  152</span>    <span class="keywordflow">if</span> (th_next != <a class="code hl_variable" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a>) {                      <span class="comment">// if it is not the same</span></div>
<div class="line"><span class="lineno">  153</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="thread_8h.html#a4ec481f4858f7894f48f951d1a59e868">thread_context_save</a> (<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">context</a>)) { <span class="comment">// Save current context, and return 1</span></div>
<div class="line"><span class="lineno">  154</span>            <a class="code hl_variable" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a> = th_next;                     <span class="comment">// update ThreadCurrentIdx</span></div>
<div class="line"><span class="lineno">  155</span>            <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a> = <a class="code hl_variable" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>[th_next];             <span class="comment">// update ThreadCurrent</span></div>
<div class="line"><span class="lineno">  156</span>            <a class="code hl_variable" href="usermem_8h.html#af044184d28c9a8b78f17bd1d8e1059b4">_usermem</a>.<a class="code hl_variable" href="struct__usermem__s.html#a092a5f4499ea31a3da83e6716d959626">ptls</a> = <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>;</div>
<div class="line"><span class="lineno">  157</span>            <a class="code hl_function" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a">thread_context_load</a> (<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">context</a>);   <span class="comment">// load contxt, exit thread_context_save</span></div>
<div class="line"><span class="lineno">  158</span>        }                                                   <span class="comment">// but with 0 as return value</span></div>
<div class="line"><span class="lineno">  159</span>    }</div>
<div class="line"><span class="lineno">  160</span>    <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a>= <a class="code hl_define" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>;                 <span class="comment">// the chosen one is RUNNNIG</span></div>
<div class="line"><span class="lineno">  161</span>}</div>
<div class="ttc" id="astruct__usermem__s_html_a092a5f4499ea31a3da83e6716d959626"><div class="ttname"><a href="struct__usermem__s.html#a092a5f4499ea31a3da83e6716d959626">_usermem_s::ptls</a></div><div class="ttdeci">struct _tls_s * ptls</div><div class="ttdoc">pointer to the thread local storage of the current thread</div><div class="ttdef"><b>Definition:</b> usermem.h:57</div></div>
<div class="ttc" id="astructthread__s_html_a668771e7e3444ba13544b50e1ff312a6"><div class="ttname"><a href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">thread_s::context</a></div><div class="ttdeci">int context[TH_CONTEXT_SIZE]</div><div class="ttdoc">table to store registers when thread lose the cpu</div><div class="ttdef"><b>Definition:</b> kthread.c:48</div></div>
<div class="ttc" id="athread_8h_html_a2d77cc7bcdfa6b6295a8bcd74803cc4a"><div class="ttname"><a href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a">thread_context_load</a></div><div class="ttdeci">int thread_context_load(int context[])</div><div class="ttdoc">kernel load the given thread registers from the context table</div></div>
<div class="ttc" id="athread_8h_html_a4ec481f4858f7894f48f951d1a59e868"><div class="ttname"><a href="thread_8h.html#a4ec481f4858f7894f48f951d1a59e868">thread_context_save</a></div><div class="ttdeci">int thread_context_save(int context[])</div><div class="ttdoc">kernel saves the given thread registers in the context table</div></div>
<div class="ttc" id="ausermem_8h_html_af044184d28c9a8b78f17bd1d8e1059b4"><div class="ttname"><a href="usermem_8h.html#af044184d28c9a8b78f17bd1d8e1059b4">_usermem</a></div><div class="ttdeci">_usermem_t _usermem</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="usermem_8h.html#af044184d28c9a8b78f17bd1d8e1059b4">_usermem</a>, <a class="el" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">thread_s::context</a>, <a class="el" href="struct__usermem__s.html#a092a5f4499ea31a3da83e6716d959626">_usermem_s::ptls</a>, <a class="el" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>, <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a">thread_context_load()</a>, <a class="el" href="thread_8h.html#a4ec481f4858f7894f48f951d1a59e868">thread_context_save()</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, <a class="el" href="kthread_8c.html#ae48ff9d5d8665f90c44ae6ad4acb5b6d">ThreadCurrentIdx</a>, and <a class="el" href="kthread_8c.html#aea4c4ea36a124f36c5a513e838d95419">ThreadTab</a>.</p>

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#a19b16adf05364471bae2840aa564329a">thread_exit()</a>, <a class="el" href="kthread_8c.html#a4e54fc344bbd735b027c03629927abb9">thread_join()</a>, <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait()</a>, and <a class="el" href="kthread_8c.html#affe2eebf6749bc36765d45ff48c926b1">thread_yield()</a>.</p>

</div>
</div>
<a id="a3ecc03b8319efabea835c1205c8fff4d" name="a3ecc03b8319efabea835c1205c8fff4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc03b8319efabea835c1205c8fff4d">&#9670;&#160;</a></span>thread_addlast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_addlast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="list_8h.html#a3b55f1cd33b93f9cc32dbe31f95e22ed">list_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   57</span>{</div>
<div class="line"><span class="lineno">   58</span>    <a class="code hl_function" href="list_8h.html#a116cfa18214dd2f855cff842bb14ca8f">list_addlast</a> (root, &amp;thread-&gt;<a class="code hl_variable" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">wait</a>);</div>
<div class="line"><span class="lineno">   59</span>}</div>
<div class="ttc" id="alist_8h_html_a116cfa18214dd2f855cff842bb14ca8f"><div class="ttname"><a href="list_8h.html#a116cfa18214dd2f855cff842bb14ca8f">list_addlast</a></div><div class="ttdeci">static void list_addlast(list_t *root, list_t *added_item)</div><div class="ttdoc">Add a new added item before the current item which is root the most often. then the added item is pla...</div><div class="ttdef"><b>Definition:</b> list.h:221</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="list_8h.html#a116cfa18214dd2f855cff842bb14ca8f">list_addlast()</a>, and <a class="el" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">thread_s::wait</a>.</p>

<p class="reference">Referenced by <a class="el" href="ksynchro_8c.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait()</a>, and <a class="el" href="ksynchro_8c.html#aa5d516e2832e4c1f4d222a79fabe76a2">thread_mutex_lock()</a>.</p>

</div>
</div>
<a id="ab6382c52388aa3e432787e2b9b4671bb" name="ab6382c52388aa3e432787e2b9b4671bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6382c52388aa3e432787e2b9b4671bb">&#9670;&#160;</a></span>thread_bootstrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void thread_bootstrap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> function is the bootstrap of the thread. It means that it is the very first function we call when the <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> returns for the very first time. In fact, <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> ends with a "jr $31" as usual but when we create a thread, $31 is initialized with the <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> address. Thus, when we return from <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> the very first time, we enter in <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a>. The function <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> cannot have any argument, since <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a" title="kernel load the given thread registers from the context table">thread_context_load()</a> does not restore $4 to $7 registers (which are the registers of arguments). So, that is the <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb" title="thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...">thread_bootstrap()</a> itself that will call the threat_start() function with the needed arguments, as we know what is the current thread, and we are able to find out what is the user function to call with which args. As the thread is just beginning to run, its state is now RUNNING </p>
<p>To sum up what is happening when a thread context is loaded:</p>
<ul>
<li>the very first time that a thread is chosen by the scheduler thread_context_load (thread) (def hcpua.S)<ul>
<li>thread_bootstrap () (def <a class="el" href="kthread_8c.html">kthread.c</a>)<ul>
<li>thread_launch (thread-&gt;fun, thread-&gt;arg, thread-&gt;start) (def hcpua.S)<ul>
<li>thread-&gt;thread_start (thread-&gt;fun, thread-&gt;arg) (def thread.c)<ul>
<li>thread-&gt;fun (thread-&gt;arg) (def uapp)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>the others times that a thread is chosen thread_context_load (thread) (def hcpua.S)<ul>
<li>return to <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb" title="Change the current thread for another, it can be unchanged if it is alone.">sched_switch()</a> (def <a class="el" href="kthread_8c.html">kthread.c</a>)<ul>
<li>return to the caller of sched_switch, 2 possibilities:<ol type="1">
<li>from a syscall<ul>
<li>return to the syscall function (e.g. tty_read) (def harch.c)<ul>
<li>return to syscall_handler (def hcpua.S)<ul>
<li>return to the app that uses the syscall (def app)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>from a isr (here, only isr_timer)<ul>
<li>return to isrcall (def harch.c)<ul>
<li>return to irq_handler (def hcpua.S)<ul>
<li>return to the interrupted code (def kernel OR uapp) </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="lineno">  269</span>{</div>
<div class="line"><span class="lineno">  270</span>    <a class="code hl_struct" href="structthread__s.html">thread_t</a> thread = <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>;                            <span class="comment">// gets the current thread</span></div>
<div class="line"><span class="lineno">  271</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>;                           <span class="comment">// the thread is now RUNNING</span></div>
<div class="line"><span class="lineno">  272</span>    <a class="code hl_function" href="thread_8h.html#a19412f68ca2922fbb153cf8107c16fce">thread_launch</a> (thread-&gt;<a class="code hl_variable" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">fun</a>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">arg</a>, thread-&gt;<a class="code hl_variable" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">start</a>);    <span class="comment">// calls : start(fun,arg)</span></div>
<div class="line"><span class="lineno">  273</span>}</div>
<div class="ttc" id="athread_8h_html_a19412f68ca2922fbb153cf8107c16fce"><div class="ttname"><a href="thread_8h.html#a19412f68ca2922fbb153cf8107c16fce">thread_launch</a></div><div class="ttdeci">int thread_launch(int fun, int arg, int start)</div><div class="ttdoc">The kernel starts any thread for the very first time with this function. This function is called by t...</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">thread_s::arg</a>, <a class="el" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">thread_s::fun</a>, <a class="el" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">thread_s::start</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>, <a class="el" href="thread_8h.html#a19412f68ca2922fbb153cf8107c16fce">thread_launch()</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#a2525e99272c4db4198bcea374d717620">thread_create()</a>.</p>

</div>
</div>
<a id="a2525e99272c4db4198bcea374d717620" name="a2525e99272c4db4198bcea374d717620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2525e99272c4db4198bcea374d717620">&#9670;&#160;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls by the kernel in order to implement the user <a class="el" href="kthread_8h.html#a227d30321d9dddb518fe5d116aa7d90b" title="Calls by the kernel in order to implement the user thread_create() syscall This function has the same...">thread_create()</a> syscall This function has the same arguments as <a class="el" href="kthread_8h.html#a227d30321d9dddb518fe5d116aa7d90b" title="Calls by the kernel in order to implement the user thread_create() syscall This function has the same...">thread_create()</a>, plus one which is the pointer to the function that will start the thread, there are two of those: one for the main thread (nammed _start defined in <a class="el" href="crt0_8c.html">crt0.c</a>) and one for the standard thread (nammed thread_start defined in thread.c). These two functions do not have the same type but it does not matter because we are converting to int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>pointer to the thread structure </td></tr>
    <tr><td class="paramname">fun</td><td>pointer to the function of the thread (cast to int) </td></tr>
    <tr><td class="paramname">arg</td><td>the argument given to fun() (cast to int) </td></tr>
    <tr><td class="paramname">start</td><td>pointer to the function which will start the thread (cast to int) This function is defined in the same address space as the thread. If it is a user thread the start function is in user space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, an error code on fealure </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  276</span>{</div>
<div class="line"><span class="lineno">  277</span>    <a class="code hl_struct" href="structthread__s.html">thread_t</a> thread = <a class="code hl_function" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc</a> (<a class="code hl_define" href="usermem_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>);                      <span class="comment">// thread is thus always aligned</span></div>
<div class="line"><span class="lineno">  278</span>    <span class="keywordflow">if</span> (thread == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4bde0de54c0b708a605ed5095959c14e">EAGAIN</a>;                          <span class="comment">// Not enough memory</span></div>
<div class="line"><span class="lineno">  279</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">kstack_b</a> = (int)thread + <a class="code hl_define" href="usermem_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> - 4;             <span class="comment">// kstack beginning (highest addr)</span></div>
<div class="line"><span class="lineno">  280</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">ustack_b</a> = (int)<a class="code hl_function" href="kmemory_8c.html#a2574fcf1422da561bbd3b950edc7f85c">malloc_ustack</a>();                    <span class="comment">// stack beginning (highest address)</span></div>
<div class="line"><span class="lineno">  281</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">ustack_e</a> = thread-&gt;<a class="code hl_variable" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">ustack_b</a> - <a class="code hl_define" href="usermem_8h.html#ad77d03e18a9477ef16ff8c4ae3c8b43d">USTACK_SIZE</a> + 4;      <span class="comment">// stack end (lowest addr)</span></div>
<div class="line"><span class="lineno">  282</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a>    = <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>;                          <span class="comment">// it can be chosen by the scheduler</span></div>
<div class="line"><span class="lineno">  283</span>    <a class="code hl_function" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init</a> (&amp;thread-&gt;<a class="code hl_variable" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">wait</a>);                                  <span class="comment">// initialize the waiting list</span></div>
<div class="line"><span class="lineno">  284</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">retval</a>   = <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;                                    <span class="comment">// default return value</span></div>
<div class="line"><span class="lineno">  285</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">join</a>     = <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;                                    <span class="comment">// no awaited thread</span></div>
<div class="line"><span class="lineno">  286</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">start</a>    = start;                                   <span class="comment">// start() will call fun(arg)</span></div>
<div class="line"><span class="lineno">  287</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">fun</a>      = fun;                                     <span class="comment">// function of the thread</span></div>
<div class="line"><span class="lineno">  288</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">arg</a>      = arg;                                     <span class="comment">// argument of the thread</span></div>
<div class="line"><span class="lineno">  289</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>     = (<a class="code hl_struct" href="struct__tls__s.html">_tls_t</a> *)(thread-&gt;<a class="code hl_variable" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">ustack_b</a> - <span class="keyword">sizeof</span>(<a class="code hl_struct" href="struct__tls__s.html">_tls_t</a>)); <span class="comment">// pointer to the current tls</span></div>
<div class="line"><span class="lineno">  290</span>    <a class="code hl_function" href="mips_2threadc_8c.html#af63f55ab4a65c97f8effe4ff21de0b1e">thread_context_init</a>(thread-&gt;<a class="code hl_variable" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">context</a>,                        <span class="comment">// table to store context</span></div>
<div class="line"><span class="lineno">  291</span>                        <a class="code hl_function" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb">thread_bootstrap</a>,                       <span class="comment">// thread_bootstrap() to begin</span></div>
<div class="line"><span class="lineno">  292</span>                        thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>);                          <span class="comment">// stack pointer addr (below tls)</span></div>
<div class="line"><span class="lineno">  293</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#ae4614b780e1a47305c562869870d6e41">krandseed</a>  = 1;                                     <span class="comment">// default kernel random seed</span></div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    *(<span class="keywordtype">int</span>*)thread-&gt;<a class="code hl_variable" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">kstack_b</a> = <a class="code hl_define" href="usermem_8h.html#a34ef3ea96595898f1452b49d29a1722a">MAGIC_STACK</a>;                      <span class="comment">// should not be erased</span></div>
<div class="line"><span class="lineno">  296</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">kstack</a>[0] = <a class="code hl_define" href="usermem_8h.html#a34ef3ea96595898f1452b49d29a1722a">MAGIC_STACK</a>;                            <span class="comment">// (is kstack_e) should not erased</span></div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    <a class="code hl_function" href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert</a> (thread);                                      <span class="comment">// insert new thread in scheduler</span></div>
<div class="line"><span class="lineno">  299</span>    *thread_p = thread;</div>
<div class="line"><span class="lineno">  300</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>-&gt;<a class="code hl_variable" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">tls_errno</a> = <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">  302</span>}</div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a4bde0de54c0b708a605ed5095959c14e"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4bde0de54c0b708a605ed5095959c14e">EAGAIN</a></div><div class="ttdeci">@ EAGAIN</div><div class="ttdef"><b>Definition:</b> errno.h:37</div></div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a></div><div class="ttdeci">@ SUCCESS</div><div class="ttdef"><b>Definition:</b> errno.h:34</div></div>
<div class="ttc" id="akmemory_8c_html_a2574fcf1422da561bbd3b950edc7f85c"><div class="ttname"><a href="kmemory_8c.html#a2574fcf1422da561bbd3b950edc7f85c">malloc_ustack</a></div><div class="ttdeci">int * malloc_ustack(void)</div><div class="ttdoc">allocate a new user stack</div><div class="ttdef"><b>Definition:</b> kmemory.c:236</div></div>
<div class="ttc" id="akmemory_8c_html_a87d8585002a620e687d68b38ab387a0e"><div class="ttname"><a href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc</a></div><div class="ttdeci">void * kmalloc(size_t size)</div><div class="ttdoc">allocate an object in the kernel address space</div><div class="ttdef"><b>Definition:</b> kmemory.c:105</div></div>
<div class="ttc" id="akthread_8c_html_ab6382c52388aa3e432787e2b9b4671bb"><div class="ttname"><a href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb">thread_bootstrap</a></div><div class="ttdeci">static void thread_bootstrap(void)</div><div class="ttdoc">thread_bootstrap() function is the bootstrap of the thread. It means that it is the very first functi...</div><div class="ttdef"><b>Definition:</b> kthread.c:268</div></div>
<div class="ttc" id="akthread_8c_html_ad094fddcf3208d43f3385ed2aa419c10"><div class="ttname"><a href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert</a></div><div class="ttdeci">static void sched_insert(thread_t thread_new)</div><div class="ttdoc">Insert a new thread, in the scheduler The scheduler is a simple table of all the threads To insert a ...</div><div class="ttdef"><b>Definition:</b> kthread.c:96</div></div>
<div class="ttc" id="alist_8h_html_a4988c174e6ecc55436d5f0e3dbbb3980"><div class="ttname"><a href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init</a></div><div class="ttdeci">static void list_init(list_t *root)</div><div class="ttdoc">Initialize of the list root.</div><div class="ttdef"><b>Definition:</b> list.h:191</div></div>
<div class="ttc" id="amips_2threadc_8c_html_af63f55ab4a65c97f8effe4ff21de0b1e"><div class="ttname"><a href="mips_2threadc_8c.html#af63f55ab4a65c97f8effe4ff21de0b1e">thread_context_init</a></div><div class="ttdeci">void thread_context_init(int context[], void *bootstrap, void *stack_pointer)</div><div class="ttdoc">Initialize the thread context at the very beginning.</div><div class="ttdef"><b>Definition:</b> threadc.c:19</div></div>
<div class="ttc" id="astruct__tls__s_html"><div class="ttname"><a href="struct__tls__s.html">_tls_s</a></div><div class="ttdoc">thread local storage structure definition. There is one structure per thread placed at the beginning ...</div><div class="ttdef"><b>Definition:</b> usermem.h:70</div></div>
<div class="ttc" id="astructthread__s_html_ae4614b780e1a47305c562869870d6e41"><div class="ttname"><a href="structthread__s.html#ae4614b780e1a47305c562869870d6e41">thread_s::krandseed</a></div><div class="ttdeci">unsigned long long krandseed</div><div class="ttdoc">each thread has its own kernel random seed, it is thread safe</div><div class="ttdef"><b>Definition:</b> kthread.c:47</div></div>
<div class="ttc" id="ausermem_8h_html_a34ef3ea96595898f1452b49d29a1722a"><div class="ttname"><a href="usermem_8h.html#a34ef3ea96595898f1452b49d29a1722a">MAGIC_STACK</a></div><div class="ttdeci">#define MAGIC_STACK</div><div class="ttdef"><b>Definition:</b> usermem.h:21</div></div>
<div class="ttc" id="ausermem_8h_html_a7d467c1d283fdfa1f2081ba1e0d01b6e"><div class="ttname"><a href="usermem_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a></div><div class="ttdeci">#define PAGE_SIZE</div><div class="ttdef"><b>Definition:</b> usermem.h:19</div></div>
<div class="ttc" id="ausermem_8h_html_ad77d03e18a9477ef16ff8c4ae3c8b43d"><div class="ttname"><a href="usermem_8h.html#ad77d03e18a9477ef16ff8c4ae3c8b43d">USTACK_SIZE</a></div><div class="ttdeci">#define USTACK_SIZE</div><div class="ttdef"><b>Definition:</b> usermem.h:20</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a5cdab21069c6c184a86d024a0aa238aa">thread_s::arg</a>, <a class="el" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">thread_s::context</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4bde0de54c0b708a605ed5095959c14e">EAGAIN</a>, <a class="el" href="structthread__s.html#a9a97385576dda275389e95ef13168cfc">thread_s::fun</a>, <a class="el" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">thread_s::join</a>, <a class="el" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc()</a>, <a class="el" href="structthread__s.html#ae4614b780e1a47305c562869870d6e41">thread_s::krandseed</a>, <a class="el" href="structthread__s.html#a1159b3f03199aed705bf099f2eb33a92">thread_s::kstack</a>, <a class="el" href="structthread__s.html#a6885e765fcfe5d2ad0e5a07c2df3ee69">thread_s::kstack_b</a>, <a class="el" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init()</a>, <a class="el" href="usermem_8h.html#a34ef3ea96595898f1452b49d29a1722a">MAGIC_STACK</a>, <a class="el" href="kmemory_8c.html#a2574fcf1422da561bbd3b950edc7f85c">malloc_ustack()</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="usermem_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>, <a class="el" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a>, <a class="el" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">thread_s::retval</a>, <a class="el" href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert()</a>, <a class="el" href="structthread__s.html#a63551d8e6d21a7370c5b3652cea282fc">thread_s::start</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb">thread_bootstrap()</a>, <a class="el" href="mips_2threadc_8c.html#af63f55ab4a65c97f8effe4ff21de0b1e">thread_context_init()</a>, <a class="el" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">_tls_s::tls_errno</a>, <a class="el" href="structthread__s.html#a8d51270c2f7572479276f7629940c3ea">thread_s::ustack_b</a>, <a class="el" href="structthread__s.html#a021e8a50ddb4a5978f18d6babfc4ea6e">thread_s::ustack_e</a>, <a class="el" href="usermem_8h.html#ad77d03e18a9477ef16ff8c4ae3c8b43d">USTACK_SIZE</a>, and <a class="el" href="structthread__s.html#a291769866cccb5d37937ef14cedc38bf">thread_s::wait</a>.</p>

<p class="reference">Referenced by <a class="el" href="kinit_8c.html#a7316311400d5b710f1b974a353b10d1c">kinit()</a>.</p>

</div>
</div>
<a id="a3eded78b19b3a81e9f88ff0d45bf8258" name="a3eded78b19b3a81e9f88ff0d45bf8258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eded78b19b3a81e9f88ff0d45bf8258">&#9670;&#160;</a></span>thread_errno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * thread_errno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return address of errno for the thread given this function is defined here, because it needs to access at the hidden thread struct </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>where errno is searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an address in user space where the last syscall error is put </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   78</span>{</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">return</span> &amp;(thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>-&gt;<a class="code hl_variable" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">tls_errno</a>);</div>
<div class="line"><span class="lineno">   80</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a>, and <a class="el" href="struct__tls__s.html#a2b0505d872f110754ab80cdfe94bf58e">_tls_s::tls_errno</a>.</p>

</div>
</div>
<a id="a19b16adf05364471bae2840aa564329a" name="a19b16adf05364471bae2840aa564329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b16adf05364471bae2840aa564329a">&#9670;&#160;</a></span>thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>retval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the current thread, it never returns (see details in <a class="el" href="kthread_8c.html">kthread.c</a>) </p>
<p><a class="el" href="kthread_8c.html#a19b16adf05364471bae2840aa564329a" title="Terminates the current thread, it never returns (see details in kthread.c)">thread_exit()</a> is to exit the current thread. Read this comment then the thread_join's comment. E1) firstly, store the return value and tell the current thread is becoming ZOMBIE E2) If the task waiting for the end of the current thread is already known E3) &ndash; then since, this task is waiting, change it state to READY Finally, definitively yield the processor (the current thread never come back Critical section: In case of real parallelism with thread_join, we must avoid the sequence: J1 J2 E1 E2 E3 J3 because then, the thread that executes the join gets the state WAIT and won't be never notified Thus, a critical section is created using the thread structure lock of the expected thread </p>
<div class="fragment"><div class="line"><span class="lineno">  336</span>{</div>
<div class="line"><span class="lineno">  337</span>    <a class="code hl_define" href="debug__off_8h.html#ade9dd5644bb3e429458471976764c5ab">INFO</a> (<span class="stringliteral">&quot;thread %p retval %p\n&quot;</span>, <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, retval);</div>
<div class="line"><span class="lineno">  338</span> </div>
<div class="line"><span class="lineno">  339</span>    <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">retval</a> = retval;                             <span class="comment">// E1: store the return value</span></div>
<div class="line"><span class="lineno">  340</span>    <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>;                     <span class="comment">//     tell that is the end</span></div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                           <span class="comment">// avoid sequence J1 J2 E1 E2 E3 J3</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">join</a> != <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)                            <span class="comment">// E2: if there is a thread waiting</span></div>
<div class="line"><span class="lineno">  344</span>        <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">join</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>;            <span class="comment">// E3: then change its state</span></div>
<div class="line"><span class="lineno">  345</span>    <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                         <span class="comment">// end of critical section</span></div>
<div class="line"><span class="lineno">  346</span>    <a class="code hl_function" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a> ();                                            <span class="comment">// at last, definitively yield proc</span></div>
<div class="line"><span class="lineno">  347</span>}</div>
<div class="ttc" id="aatomic_8h_html_a73864b9b10141e82915121078d853a9e"><div class="ttname"><a href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a></div><div class="ttdeci">void spin_unlock(spinlock_t *lock)</div><div class="ttdoc">release the lock</div></div>
<div class="ttc" id="aatomic_8h_html_a92a25e1136e165cc5472d68e3901e364"><div class="ttname"><a href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a></div><div class="ttdeci">void spin_lock(spinlock_t *lock)</div><div class="ttdoc">get the lock, block until success</div></div>
<div class="ttc" id="adebug__off_8h_html_ade9dd5644bb3e429458471976764c5ab"><div class="ttname"><a href="debug__off_8h.html#ade9dd5644bb3e429458471976764c5ab">INFO</a></div><div class="ttdeci">#define INFO(fmt, arg...)</div><div class="ttdef"><b>Definition:</b> debug_off.h:28</div></div>
<div class="ttc" id="akthread_8c_html_a79c9880ce2be11d3a2c217c383d256fb"><div class="ttname"><a href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a></div><div class="ttdeci">static void sched_switch(void)</div><div class="ttdoc">Change the current thread for another, it can be unchanged if it is alone.</div><div class="ttdef"><b>Definition:</b> kthread.c:149</div></div>
<div class="ttc" id="astructthread__s_html_a483959ed6abed6c12f49643c4495a7b1"><div class="ttname"><a href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">thread_s::lock</a></div><div class="ttdeci">spinlock_t lock</div><div class="ttdoc">lock to protected structure during modification</div><div class="ttdef"><b>Definition:</b> kthread.c:38</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="debug__off_8h.html#ade9dd5644bb3e429458471976764c5ab">INFO</a>, <a class="el" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">thread_s::join</a>, <a class="el" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">thread_s::lock</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">thread_s::retval</a>, <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, <a class="el" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

</div>
</div>
<a id="a79b0f0a19a09db45e1689ff011f6109b" name="a79b0f0a19a09db45e1689ff011f6109b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b0f0a19a09db45e1689ff011f6109b">&#9670;&#160;</a></span>thread_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> thread_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="list_8h.html#a3b55f1cd33b93f9cc32dbe31f95e22ed">list_t</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   62</span>{</div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="list_8h.html#a99f8755f2301e99adad3c8490df79052">list_item</a> (item, <span class="keyword">struct</span> <a class="code hl_struct" href="structthread__s.html">thread_s</a>, wait);</div>
<div class="line"><span class="lineno">   64</span>}</div>
<div class="ttc" id="alist_8h_html_a99f8755f2301e99adad3c8490df79052"><div class="ttname"><a href="list_8h.html#a99f8755f2301e99adad3c8490df79052">list_item</a></div><div class="ttdeci">#define list_item(ITEM, TYPE, MEMBER)</div><div class="ttdoc">Macro to get the address of the container of a list item.</div><div class="ttdef"><b>Definition:</b> list.h:183</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="list_8h.html#a99f8755f2301e99adad3c8490df79052">list_item</a>.</p>

<p class="reference">Referenced by <a class="el" href="ksynchro_8c.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait()</a>, and <a class="el" href="ksynchro_8c.html#ad515bf71cd806fc2d1a5c4143aca3988">thread_mutex_unlock()</a>.</p>

</div>
</div>
<a id="a4e54fc344bbd735b027c03629927abb9" name="a4e54fc344bbd735b027c03629927abb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e54fc344bbd735b027c03629927abb9">&#9670;&#160;</a></span>thread_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread_expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a thread termination (see details in <a class="el" href="kthread_8c.html">kthread.c</a>) </p>
<p>Please, read first the <a class="el" href="kthread_8c.html#a19b16adf05364471bae2840aa564329a" title="Terminates the current thread, it never returns (see details in kthread.c)">thread_exit()</a> comment. <a class="el" href="kthread_8c.html#a4e54fc344bbd735b027c03629927abb9" title="Wait for a thread termination (see details in kthread.c)">thread_join()</a> is to wait another thread. J1) firstly, tell the excepted thread that the current thread is waiting for it J2) If the expected thread is still alive, J3) &ndash; then wait for it if the expected thread is already a ZOMBIE, so take its return value and change it to DEAD Critical section: see the comment of thread_exit TODO check is thread_expected is a real thread (add a MAGIC number is struct <a class="el" href="structthread__s.html" title="thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...">thread_s</a> </p>
<div class="fragment"><div class="line"><span class="lineno">  359</span>{</div>
<div class="line"><span class="lineno">  360</span>    <a class="code hl_define" href="debug__off_8h.html#ade9dd5644bb3e429458471976764c5ab">INFO</a> (<span class="stringliteral">&quot;thread %p expects %p\n&quot;</span>, <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, thread_expected);</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">if</span> (thread_expected == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4e376a13d0c1557d399f473218915625">ESRCH</a>;                  <span class="comment">// Error code</span></div>
<div class="line"><span class="lineno">  363</span>    thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">join</a> = <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>;                      <span class="comment">// J1: tell ThreadCurrent is waiting</span></div>
<div class="line"><span class="lineno">  364</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                         <span class="comment">// avoid J1 J2 E1 E2 E3 J3</span></div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">if</span> (thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> != <a class="code hl_define" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>) {            <span class="comment">// J2: if expected thread not ended</span></div>
<div class="line"><span class="lineno">  366</span>        <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>;                   <span class="comment">// J3: then wait for it</span></div>
<div class="line"><span class="lineno">  367</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                   <span class="comment">// end of critical section</span></div>
<div class="line"><span class="lineno">  368</span>        <a class="code hl_function" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a> ();                                        <span class="comment">// yield the proc till READY</span></div>
<div class="line"><span class="lineno">  369</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  370</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                   <span class="comment">// end of critical section</span></div>
<div class="line"><span class="lineno">  371</span>    }</div>
<div class="line"><span class="lineno">  372</span>    *retval = thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">retval</a>;                          <span class="comment">// get the return value</span></div>
<div class="line"><span class="lineno">  373</span>    thread_expected-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#aeae3234bde1a15d5c671a41286949bc5">TH_STATE_DEAD</a>;                     <span class="comment">// finally, the thread is DEAD</span></div>
<div class="line"><span class="lineno">  374</span> </div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">  376</span>}</div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a4e376a13d0c1557d399f473218915625"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4e376a13d0c1557d399f473218915625">ESRCH</a></div><div class="ttdeci">@ ESRCH</div><div class="ttdef"><b>Definition:</b> errno.h:54</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4e376a13d0c1557d399f473218915625">ESRCH</a>, <a class="el" href="debug__off_8h.html#ade9dd5644bb3e429458471976764c5ab">INFO</a>, <a class="el" href="structthread__s.html#a84fafe08d8ef25fc4b5a8fb1e833619c">thread_s::join</a>, <a class="el" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">thread_s::lock</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__s.html#aeefa131a48c8c3c45e6c3c0819f21cd0">thread_s::retval</a>, <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8h.html#aeae3234bde1a15d5c671a41286949bc5">TH_STATE_DEAD</a>, <a class="el" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>, <a class="el" href="kthread_8h.html#a55287315008b2fea47936dc065bbabb7">TH_STATE_ZOMBIE</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

</div>
</div>
<a id="a2bcd5d32174e1f6b8b4562b4066a8b06" name="a2bcd5d32174e1f6b8b4562b4066a8b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcd5d32174e1f6b8b4562b4066a8b06">&#9670;&#160;</a></span>thread_krandseed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long * thread_krandseed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return address of krandseed for the thread given this function is defined here, because it needs to access at the hidden thread struct </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>where krandseed is searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an address in user space where the last syscall error is put </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   73</span>{</div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">return</span> &amp;(thread-&gt;<a class="code hl_variable" href="structthread__s.html#ae4614b780e1a47305c562869870d6e41">krandseed</a>);</div>
<div class="line"><span class="lineno">   75</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#ae4614b780e1a47305c562869870d6e41">thread_s::krandseed</a>.</p>

</div>
</div>
<a id="a95c63c8faef6c13da432a94800ad2acb" name="a95c63c8faef6c13da432a94800ad2acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c63c8faef6c13da432a94800ad2acb">&#9670;&#160;</a></span>thread_main_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_main_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load the context of the <a class="el" href="barrier_2main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a> thread, only used by kinit </p>
<dl class="section return"><dt>Returns</dt><dd>nothing but the thread is launched and never come back </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  305</span>{</div>
<div class="line"><span class="lineno">  306</span>    <a class="code hl_variable" href="usermem_8h.html#af044184d28c9a8b78f17bd1d8e1059b4">_usermem</a>.<a class="code hl_variable" href="struct__usermem__s.html#a092a5f4499ea31a3da83e6716d959626">ptls</a> = thread-&gt;<a class="code hl_variable" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">ptls</a>;</div>
<div class="line"><span class="lineno">  307</span>    <a class="code hl_function" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a">thread_context_load</a> (thread-&gt;<a class="code hl_variable" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">context</a>);</div>
<div class="line"><span class="lineno">  308</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="usermem_8h.html#af044184d28c9a8b78f17bd1d8e1059b4">_usermem</a>, <a class="el" href="structthread__s.html#a668771e7e3444ba13544b50e1ff312a6">thread_s::context</a>, <a class="el" href="struct__usermem__s.html#a092a5f4499ea31a3da83e6716d959626">_usermem_s::ptls</a>, <a class="el" href="structthread__s.html#a7ad218d5b7c4b6bc9c4602e6b1a89815">thread_s::ptls</a>, and <a class="el" href="thread_8h.html#a2d77cc7bcdfa6b6295a8bcd74803cc4a">thread_context_load()</a>.</p>

<p class="reference">Referenced by <a class="el" href="kinit_8c.html#a7316311400d5b710f1b974a353b10d1c">kinit()</a>.</p>

</div>
</div>
<a id="acc9196e88e8db0daa5b13544cfe62996" name="acc9196e88e8db0daa5b13544cfe62996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9196e88e8db0daa5b13544cfe62996">&#9670;&#160;</a></span>thread_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a>. In some cases, when <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called just before <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> has had time to put the current thread in the WAIT state (this is possible, since <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called by another thread running on another processor) then the current thread is already READY but <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> yields the processor anyway, so the current thread should lose the processor for a while, until the scheduler chooses it again. </p>
<p>Start to read the <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> comment to understand what is T0 and T1. T1 calls the tread_notify() function when the resource expected by T0 has occurred. When T1 enter the critical section of thread_notify, there are two possibilities 1) T0 already passed through the critical section of thread_wait and so T0 is in WAIT 2) T0 has not yet crossed the critical section of thread_wait and T0 is therefore in RUNNING yet. In both cases, we must ask T0 to notify, which is done by setting T0's state to READY </p>
<div class="fragment"><div class="line"><span class="lineno">  421</span>{</div>
<div class="line"><span class="lineno">  422</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                           <span class="comment">// !--! critical section</span></div>
<div class="line"><span class="lineno">  423</span>    thread-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>;                             <span class="comment">// (RUNNING or WAIT) to READY</span></div>
<div class="line"><span class="lineno">  424</span>    <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                         <span class="comment">// !--! end of critical section</span></div>
<div class="line"><span class="lineno">  425</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">thread_s::lock</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

<p class="reference">Referenced by <a class="el" href="ksynchro_8c.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait()</a>, and <a class="el" href="ksynchro_8c.html#ad515bf71cd806fc2d1a5c4143aca3988">thread_mutex_unlock()</a>.</p>

</div>
</div>
<a id="a0c0fd0ef94a8688f65d53216ae6c33e7" name="a0c0fd0ef94a8688f65d53216ae6c33e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0fd0ef94a8688f65d53216ae6c33e7">&#9670;&#160;</a></span>thread_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a>. In some cases, when <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called just before <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> has had time to put the current thread in the WAIT state (this is possible, since <a class="el" href="kthread_8h.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> is called by another thread running on another processor) then the current thread is already READY but <a class="el" href="kthread_8h.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> yields the processor anyway, so the current thread should lose the processor for a while, until the scheduler chooses it again. </p>
<p><a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> and <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> are made to handle the WAIT state, please read both comments. Use this function to put the current thread (say T0) into a WAIT state. We need this when T0 has just tried to acquire a busy resource. We assume that T0 has already been added to the resource's waiting list, so we still need to detach T0 from its processor's availability list. The problem is that the resource may become available during the state change of T0. Suppose another thread (say T1) returns the resource and calls thread_notify(T0). T1 is necessarily running on another CPU, so there is a risk that T0 will become READY (because of the call to thread_notify(T0)) with the resource in its possession and then become WAIT (because of the call to <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> just after). In this case, T0 will never notified again. This is the end. there are two possibilities: A [ wait then notify ] or B [ notify then wait ] A) That is the normal case. T0 is first detached from ready list, then secondly, T0 is notified and become READY B) That is a abnormal case. T0 begins to notify, because T1 gives it the resource and calls <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> then T0 becomes READY, but just after that T0 calls <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a>! Thus, <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a>, called by T0, must know that <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> has already been called, it is simply possible by looking its state. If T0 is always RUNNING, then it means that <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> has not been called yet, because otherwise the state would have been READY In that case T0 has to wait, otherwise T0 is READY and we DO NOT change the state The lock is to protect the sequence [ read - test - modification ] Note that it is possible that the notify() occurs after unlocking and just before <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb" title="Change the current thread for another, it can be unchanged if it is alone.">sched_switch()</a>. In this case, T0 will be READY but will lose the CPU even if it owns the resource. This is unfortunate, as the resource is locked for a quantum of time, but it is not fatal. </p>
<div class="fragment"><div class="line"><span class="lineno">  404</span>{</div>
<div class="line"><span class="lineno">  405</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                           <span class="comment">// !--! critical section</span></div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> == <a class="code hl_define" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>)               <span class="comment">// thread_notify not happened yet</span></div>
<div class="line"><span class="lineno">  407</span>         <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>;                  <span class="comment">// give the CPU back</span></div>
<div class="line"><span class="lineno">  408</span>    <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;<a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">lock</a>);                         <span class="comment">// !--! end of critical section</span></div>
<div class="line"><span class="lineno">  409</span>    <a class="code hl_function" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a> ();                                            <span class="comment">// then switch the thread</span></div>
<div class="line"><span class="lineno">  410</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__s.html#a483959ed6abed6c12f49643c4495a7b1">thread_s::lock</a>, <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="kthread_8h.html#a83c4c9d919043cd3b5bac98b7250d506">TH_STATE_RUNNING</a>, <a class="el" href="kthread_8h.html#a75c1c2f7da0a338d818a2950b582b74a">TH_STATE_WAIT</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

<p class="reference">Referenced by <a class="el" href="ksynchro_8c.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait()</a>, and <a class="el" href="ksynchro_8c.html#aa5d516e2832e4c1f4d222a79fabe76a2">thread_mutex_lock()</a>.</p>

</div>
</div>
<a id="affe2eebf6749bc36765d45ff48c926b1" name="affe2eebf6749bc36765d45ff48c926b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe2eebf6749bc36765d45ff48c926b1">&#9670;&#160;</a></span>thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes the current thread to give up the CPU in order to give it to another. </p>
<p>Use this function to yield the CPU while the thread is in a RUNNING state, which means that the thread is not waiting for any resource (as a device, mutex or anything else), so just we need to put it in a READY state and try to switch to another thread. It is not necessary to take the thread lock, since no one will change the state at this moment If thread is the only READY, it will take the CPU again. </p>
<div class="fragment"><div class="line"><span class="lineno">  318</span>{</div>
<div class="line"><span class="lineno">  319</span>    <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>-&gt;<a class="code hl_variable" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">state</a> = <a class="code hl_define" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>;                      <span class="comment">// yield the CPU but always READY</span></div>
<div class="line"><span class="lineno">  320</span>    <a class="code hl_function" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch</a> ();                                            <span class="comment">// Try to change thread</span></div>
<div class="line"><span class="lineno">  321</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">  322</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>, <a class="el" href="structthread__s.html#ab3fce89938b5156047553299f71a1370">thread_s::state</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8h.html#a1887e40b17ecfda05b4a398375d527fb">TH_STATE_READY</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

<p class="reference">Referenced by <a class="el" href="ns16550_8c.html#aa0c873ae215d7bac2765f28eab606ba2">ns16550_read()</a>, <a class="el" href="almo1-mips_2soc_8c.html#aeb589179b71725cd918f71b4f23b21d2">soc_timer_init()</a>, and <a class="el" href="soclib-tty_8c.html#a4431857eb67ef282186a88fda6dcd89e">soclib_tty_read()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1da5431310f6068f6d1113c402eff5f8" name="a1da5431310f6068f6d1113c402eff5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5431310f6068f6d1113c402eff5f8">&#9670;&#160;</a></span>ThreadCurrent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> ThreadCurrent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointeur to the current RUNNING thread (only one per processor) TODO should be an array if there are several processor TODO add a variable to count the number of threads and check it when tbread_create. </p>

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#a02cfe68dc8f379c88d448172f997b09e">sched_dump()</a>, <a class="el" href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert()</a>, <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>, <a class="el" href="ksynchro_8c.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait()</a>, <a class="el" href="kthread_8c.html#ab6382c52388aa3e432787e2b9b4671bb">thread_bootstrap()</a>, <a class="el" href="kthread_8c.html#a19b16adf05364471bae2840aa564329a">thread_exit()</a>, <a class="el" href="kthread_8c.html#a4e54fc344bbd735b027c03629927abb9">thread_join()</a>, <a class="el" href="ksynchro_8c.html#af85d5d2e4a36615955a7cfbae10eeec5">thread_mutex_destroy()</a>, <a class="el" href="ksynchro_8c.html#aa5d516e2832e4c1f4d222a79fabe76a2">thread_mutex_lock()</a>, <a class="el" href="ksynchro_8c.html#ad515bf71cd806fc2d1a5c4143aca3988">thread_mutex_unlock()</a>, <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify()</a>, <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait()</a>, and <a class="el" href="kthread_8c.html#affe2eebf6749bc36765d45ff48c926b1">thread_yield()</a>.</p>

</div>
</div>
<a id="ae48ff9d5d8665f90c44ae6ad4acb5b6d" name="ae48ff9d5d8665f90c44ae6ad4acb5b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48ff9d5d8665f90c44ae6ad4acb5b6d">&#9670;&#160;</a></span>ThreadCurrentIdx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ThreadCurrentIdx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#ab9600d6716f732f0ca9bac066fa6ed7c">__attribute__()</a>, <a class="el" href="kthread_8c.html#a02cfe68dc8f379c88d448172f997b09e">sched_dump()</a>, and <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>.</p>

</div>
</div>
<a id="aea4c4ea36a124f36c5a513e838d95419" name="aea4c4ea36a124f36c5a513e838d95419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4c4ea36a124f36c5a513e838d95419">&#9670;&#160;</a></span>ThreadTab</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kthread_8h.html#a755fbb4a945decf90cb1c0eb5fd16878">thread_t</a> ThreadTab[<a class="el" href="kthread_8h.html#a425c1da89e5866d87fc20a624da7cbec">THREAD_MAX</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="kthread_8c.html#ab9600d6716f732f0ca9bac066fa6ed7c">__attribute__()</a>, <a class="el" href="kthread_8c.html#a02cfe68dc8f379c88d448172f997b09e">sched_dump()</a>, <a class="el" href="kthread_8c.html#ad094fddcf3208d43f3385ed2aa419c10">sched_insert()</a>, and <a class="el" href="kthread_8c.html#a79c9880ce2be11d3a2c217c383d256fb">sched_switch()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
