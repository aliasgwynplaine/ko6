<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ko6: src/soft/kernel/ksynchro.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo55.png"/></td>
  <td id="projectalign">
   <div id="projectname">ko6
   </div>
   <div id="projectbrief">ko6 (prononce it &#39;kit-O-sys&#39; O is  the letter not the number) is a small operating system for educationnal purpose</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_8785740846211ac34fd04c61a1fdd888.html">soft</a></li><li class="navelem"><a class="el" href="dir_f1add7e60d3117fa5e9acdff1c3c9be3.html">kernel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ksynchro.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="ksynchro_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae7e296fd691b7e81249a311441936f79"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structthread__mutex__s.html">thread_mutex_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a></td></tr>
<tr class="memdesc:ae7e296fd691b7e81249a311441936f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">hidden mutex type, the other modules do not what is in the mutex structure  <br /></td></tr>
<tr class="separator:ae7e296fd691b7e81249a311441936f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130bec7a93458fc744ffe3d6b7c85e8c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structthread__barrier__s.html">thread_barrier_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a></td></tr>
<tr class="memdesc:a130bec7a93458fc744ffe3d6b7c85e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">hidden barrier type, the user do not what is in the barrier structure  <br /></td></tr>
<tr class="separator:a130bec7a93458fc744ffe3d6b7c85e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fbf4c52b56586ce18013333c7a1d37e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#a2fbf4c52b56586ce18013333c7a1d37e">thread_mutex_init</a> (<a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:a2fbf4c52b56586ce18013333c7a1d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new mutex and initializes mutex variable with the new mutex (side effect) it is a nutex with error checking  <br /></td></tr>
<tr class="separator:a2fbf4c52b56586ce18013333c7a1d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85d5d2e4a36615955a7cfbae10eeec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#af85d5d2e4a36615955a7cfbae10eeec5">thread_mutex_destroy</a> (<a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:af85d5d2e4a36615955a7cfbae10eeec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy the referenced mutex If the mutex is locked the destruction is not done, this is an error  <br /></td></tr>
<tr class="separator:af85d5d2e4a36615955a7cfbae10eeec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d516e2832e4c1f4d222a79fabe76a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#aa5d516e2832e4c1f4d222a79fabe76a2">thread_mutex_lock</a> (<a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:aa5d516e2832e4c1f4d222a79fabe76a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock the referenced mutex, it is a blocking operation. If the mutex is already locked, the calling thread blocks until the mutex becomes available. If the mutex does not exist or is already locked, this is an error  <br /></td></tr>
<tr class="separator:aa5d516e2832e4c1f4d222a79fabe76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad515bf71cd806fc2d1a5c4143aca3988"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#ad515bf71cd806fc2d1a5c4143aca3988">thread_mutex_unlock</a> (<a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ad515bf71cd806fc2d1a5c4143aca3988"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlock the referenced mutex If the mutex does not exist or is not locked or has been locked by another, this is an error that causes exit with error  <br /></td></tr>
<tr class="separator:ad515bf71cd806fc2d1a5c4143aca3988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea6885b17fdfc05ad0414fbaa41dd89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#adea6885b17fdfc05ad0414fbaa41dd89">thread_barrier_init</a> (<a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *<a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>, size_t count)</td></tr>
<tr class="memdesc:adea6885b17fdfc05ad0414fbaa41dd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates or initialize a barrier depending the value of barrier parameter  <br /></td></tr>
<tr class="separator:adea6885b17fdfc05ad0414fbaa41dd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6f07b8093fabd5e248aae8b7e64abb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#aea6f07b8093fabd5e248aae8b7e64abb">thread_barrier_wait</a> (<a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *<a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>)</td></tr>
<tr class="memdesc:aea6f07b8093fabd5e248aae8b7e64abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait to the referenced barrier, it is a blocking operation for all thread but the last the last arrived thread doesn't wait and notifies the other threads which becomes READY  <br /></td></tr>
<tr class="separator:aea6f07b8093fabd5e248aae8b7e64abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384a3caafcd4e7c672a583fc4183f983"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ksynchro_8h.html#a384a3caafcd4e7c672a583fc4183f983">thread_barrier_destroy</a> (<a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *<a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>)</td></tr>
<tr class="memdesc:a384a3caafcd4e7c672a583fc4183f983"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy the referenced barrier If a thread is waiting at the barrier, then the destruction is not done, it is an error  <br /></td></tr>
<tr class="separator:a384a3caafcd4e7c672a583fc4183f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a130bec7a93458fc744ffe3d6b7c85e8c" name="a130bec7a93458fc744ffe3d6b7c85e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130bec7a93458fc744ffe3d6b7c85e8c">&#9670;&#160;</a></span>thread_barrier_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structthread__barrier__s.html">thread_barrier_s</a>* <a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hidden barrier type, the user do not what is in the barrier structure </p>

</div>
</div>
<a id="ae7e296fd691b7e81249a311441936f79" name="ae7e296fd691b7e81249a311441936f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e296fd691b7e81249a311441936f79">&#9670;&#160;</a></span>thread_mutex_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structthread__mutex__s.html">thread_mutex_s</a>* <a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>hidden mutex type, the other modules do not what is in the mutex structure </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a384a3caafcd4e7c672a583fc4183f983" name="a384a3caafcd4e7c672a583fc4183f983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384a3caafcd4e7c672a583fc4183f983">&#9670;&#160;</a></span>thread_barrier_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_barrier_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroy the referenced barrier If a thread is waiting at the barrier, then the destruction is not done, it is an error </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>a pointer referencing a barrier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SUCCESS if it all goes fine or EINVAL wrong argument EBUSY The implementation has detected an attempt to destroy a barrier while it is in use (for example, while being used in a <a class="el" href="ksynchro_8h.html#aea6f07b8093fabd5e248aae8b7e64abb" title="wait to the referenced barrier, it is a blocking operation for all thread but the last the last arriv...">thread_barrier_wait()</a> <br  />
 call) by another thread. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  202</span>{</div>
<div class="line"><span class="lineno">  203</span>    <a class="code hl_struct" href="structthread__barrier__s.html">thread_barrier_t</a> b = *<a class="code hl_variable" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>;                          <span class="comment">// get the barrier pointer</span></div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">if</span> (b == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                           <span class="comment">// b is not created</span></div>
<div class="line"><span class="lineno">  206</span>    <span class="keywordflow">if</span> (b &amp;&amp; (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">magic</a> != <a class="code hl_define" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>)) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;    <span class="comment">// check that it is barrier (MAGIC)</span></div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                                   <span class="comment">// get the ownership</span></div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">if</span> (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a> != 0) {                                  <span class="comment">// if barrier is in use</span></div>
<div class="line"><span class="lineno">  210</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                             <span class="comment">// release the lock</span></div>
<div class="line"><span class="lineno">  211</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>;                                       <span class="comment">// return an error</span></div>
<div class="line"><span class="lineno">  212</span>    }</div>
<div class="line"><span class="lineno">  213</span>    <a class="code hl_function" href="kmemory_8c.html#a64c1f767a18f26f8c8cabd0f82f3e04d">kfree</a> (b, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code hl_struct" href="structthread__barrier__s.html">thread_barrier_s</a>));            <span class="comment">// destroys barrier &amp; erases its memory</span></div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;                                         <span class="comment">// erasing the memory releases the lock</span></div>
<div class="line"><span class="lineno">  216</span>}</div>
<div class="ttc" id="aatomic_8h_html_a73864b9b10141e82915121078d853a9e"><div class="ttname"><a href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a></div><div class="ttdeci">void spin_unlock(spinlock_t *lock)</div><div class="ttdoc">release the lock</div></div>
<div class="ttc" id="aatomic_8h_html_a92a25e1136e165cc5472d68e3901e364"><div class="ttname"><a href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a></div><div class="ttdeci">void spin_lock(spinlock_t *lock)</div><div class="ttdoc">get the lock, block until success</div></div>
<div class="ttc" id="abarrier_2main_8c_html_a779bfbbb688cf46720cfb65109ea4858"><div class="ttname"><a href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a></div><div class="ttdeci">pthread_barrier_t barrier</div><div class="ttdef"><b>Definition:</b> main.c:20</div></div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a></div><div class="ttdeci">@ EINVAL</div><div class="ttdef"><b>Definition:</b> errno.h:43</div></div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a></div><div class="ttdeci">@ EBUSY</div><div class="ttdef"><b>Definition:</b> errno.h:38</div></div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a></div><div class="ttdeci">@ SUCCESS</div><div class="ttdef"><b>Definition:</b> errno.h:34</div></div>
<div class="ttc" id="akfs_8c_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> kfs.c:24</div></div>
<div class="ttc" id="akmemory_8c_html_a64c1f767a18f26f8c8cabd0f82f3e04d"><div class="ttname"><a href="kmemory_8c.html#a64c1f767a18f26f8c8cabd0f82f3e04d">kfree</a></div><div class="ttdeci">void kfree(void *obj, size_t size)</div><div class="ttdoc">free an allocated object with kmalloc()</div><div class="ttdef"><b>Definition:</b> kmemory.c:132</div></div>
<div class="ttc" id="aksynchro_8c_html_a0841bee433f37156e826b327718b9db2"><div class="ttname"><a href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a></div><div class="ttdeci">#define MAGIC_BARRIER</div><div class="ttdef"><b>Definition:</b> ksynchro.c:133</div></div>
<div class="ttc" id="astructthread__barrier__s_html"><div class="ttname"><a href="structthread__barrier__s.html">thread_barrier_s</a></div><div class="ttdef"><b>Definition:</b> ksynchro.c:135</div></div>
<div class="ttc" id="astructthread__barrier__s_html_a0ca24d9e62459d13238ea86bbb85c61c"><div class="ttname"><a href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">thread_barrier_s::magic</a></div><div class="ttdeci">int magic</div><div class="ttdoc">magic number to check the validity of the barrier</div><div class="ttdef"><b>Definition:</b> ksynchro.c:136</div></div>
<div class="ttc" id="astructthread__barrier__s_html_a2d4b05b20a64eb8536021d7a553c1de1"><div class="ttname"><a href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">thread_barrier_s::waiting</a></div><div class="ttdeci">size_t waiting</div><div class="ttdoc">number of threads waiting</div><div class="ttdef"><b>Definition:</b> ksynchro.c:139</div></div>
<div class="ttc" id="astructthread__barrier__s_html_a8bbb69142ae57e50b5c83c31a8b00138"><div class="ttname"><a href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">thread_barrier_s::lock</a></div><div class="ttdeci">spinlock_t lock</div><div class="ttdoc">protection against parallel modifications</div><div class="ttdef"><b>Definition:</b> ksynchro.c:137</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="kmemory_8c.html#a64c1f767a18f26f8c8cabd0f82f3e04d">kfree()</a>, <a class="el" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">thread_barrier_s::lock</a>, <a class="el" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">thread_barrier_s::magic</a>, <a class="el" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, and <a class="el" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">thread_barrier_s::waiting</a>.</p>

</div>
</div>
<a id="adea6885b17fdfc05ad0414fbaa41dd89" name="adea6885b17fdfc05ad0414fbaa41dd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea6885b17fdfc05ad0414fbaa41dd89">&#9670;&#160;</a></span>thread_barrier_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_barrier_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *&#160;</td>
          <td class="paramname"><em>barrier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates or initialize a barrier depending the value of barrier parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>a pointer referencing the barrier, there are two cases 1) if *barrier == NULL then allocate a new barrier, then initialize count 2) if *barrier != NULL it the barrier already exists, just initialize count </td></tr>
    <tr><td class="paramname">count</td><td>number of expected threads for this barrier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SUCCESS if it all goes fine or EINVAL barrier is not a barrier or the value specified by count is equal to zero. ENOMEM Insufficient memory exists to initialize the barrier EBUSY The implementation has detected an attempt to reinitialize a barrier while it is in use (for example, while being used in a <a class="el" href="ksynchro_8h.html#aea6f07b8093fabd5e248aae8b7e64abb" title="wait to the referenced barrier, it is a blocking operation for all thread but the last the last arriv...">thread_barrier_wait()</a> <br  />
 call) by another thread. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  144</span>{</div>
<div class="line"><span class="lineno">  145</span>    <a class="code hl_struct" href="structthread__barrier__s.html">thread_barrier_t</a> b = *<a class="code hl_variable" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>;                          <span class="comment">// get the barrier pointer</span></div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">if</span> (count == 0) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                          <span class="comment">// count must be &gt; 0</span></div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">if</span> (b == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {                                        <span class="comment">// if we need a new barrier</span></div>
<div class="line"><span class="lineno">  150</span>        b = <a class="code hl_function" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code hl_struct" href="structthread__barrier__s.html">thread_barrier_s</a>));     <span class="comment">// allocates a new barrier</span></div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">if</span> (b == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca">ENOMEM</a>;                       <span class="comment">// test if there is enough memory</span></div>
<div class="line"><span class="lineno">  152</span>        b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">magic</a> = <a class="code hl_define" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>;                           <span class="comment">// tell it is a BARRIER</span></div>
<div class="line"><span class="lineno">  153</span>        b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a> = 0;                                        <span class="comment">// free the lock</span></div>
<div class="line"><span class="lineno">  154</span>        b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">expected</a> = count;                                <span class="comment">// init the expected threads</span></div>
<div class="line"><span class="lineno">  155</span>        b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a> = 0;                                     <span class="comment">// init the counter of waiting threads</span></div>
<div class="line"><span class="lineno">  156</span>        <a class="code hl_function" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">wait</a>);                               <span class="comment">// init the waiting list</span></div>
<div class="line"><span class="lineno">  157</span>        *<a class="code hl_variable" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a> = b;                                       <span class="comment">// at last, init. the return variable</span></div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;                                     <span class="comment">// it&#39;s fine</span></div>
<div class="line"><span class="lineno">  159</span>    }</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    <span class="keywordflow">if</span> (b &amp;&amp; (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">magic</a> != <a class="code hl_define" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>)) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;    <span class="comment">// it is not an old barrier</span></div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                                   <span class="comment">// get the ownership</span></div>
<div class="line"><span class="lineno">  164</span>    <span class="keywordflow">if</span> (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a> != 0) {                                  <span class="comment">// if someone is waiting</span></div>
<div class="line"><span class="lineno">  165</span>        <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                               <span class="comment">// release the ownership</span></div>
<div class="line"><span class="lineno">  166</span>        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>;                                       <span class="comment">// return an error</span></div>
<div class="line"><span class="lineno">  167</span>    }</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">expected</a> = count;                                    <span class="comment">// set the number of expected threads</span></div>
<div class="line"><span class="lineno">  170</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                                   <span class="comment">// release the ownership</span></div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;                                         <span class="comment">// it&#39;s fine</span></div>
<div class="line"><span class="lineno">  173</span>}</div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca">ENOMEM</a></div><div class="ttdeci">@ ENOMEM</div><div class="ttdef"><b>Definition:</b> errno.h:47</div></div>
<div class="ttc" id="akmemory_8c_html_a87d8585002a620e687d68b38ab387a0e"><div class="ttname"><a href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc</a></div><div class="ttdeci">void * kmalloc(size_t size)</div><div class="ttdoc">allocate an object in the kernel address space</div><div class="ttdef"><b>Definition:</b> kmemory.c:105</div></div>
<div class="ttc" id="alist_8h_html_a4988c174e6ecc55436d5f0e3dbbb3980"><div class="ttname"><a href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init</a></div><div class="ttdeci">static void list_init(list_t *root)</div><div class="ttdoc">Initialize of the list root.</div><div class="ttdef"><b>Definition:</b> list.h:191</div></div>
<div class="ttc" id="astructthread__barrier__s_html_a49aeee62a81db234144e01be301540ef"><div class="ttname"><a href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">thread_barrier_s::expected</a></div><div class="ttdeci">size_t expected</div><div class="ttdoc">number of expected threads</div><div class="ttdef"><b>Definition:</b> ksynchro.c:138</div></div>
<div class="ttc" id="astructthread__barrier__s_html_a64884bf0d1a1ef7f4a06521553e2e066"><div class="ttname"><a href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">thread_barrier_s::wait</a></div><div class="ttdeci">list_t wait</div><div class="ttdoc">list element to chain threads that are wainting for the mutex</div><div class="ttdef"><b>Definition:</b> ksynchro.c:140</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca">ENOMEM</a>, <a class="el" href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">thread_barrier_s::expected</a>, <a class="el" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc()</a>, <a class="el" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init()</a>, <a class="el" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">thread_barrier_s::lock</a>, <a class="el" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">thread_barrier_s::magic</a>, <a class="el" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">thread_barrier_s::wait</a>, and <a class="el" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">thread_barrier_s::waiting</a>.</p>

</div>
</div>
<a id="aea6f07b8093fabd5e248aae8b7e64abb" name="aea6f07b8093fabd5e248aae8b7e64abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6f07b8093fabd5e248aae8b7e64abb">&#9670;&#160;</a></span>thread_barrier_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_barrier_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#a130bec7a93458fc744ffe3d6b7c85e8c">thread_barrier_t</a> *&#160;</td>
          <td class="paramname"><em>barrier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wait to the referenced barrier, it is a blocking operation for all thread but the last the last arrived thread doesn't wait and notifies the other threads which becomes READY </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>a pointer referencing a barrier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SUCCESS or FEALURE </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  176</span>{</div>
<div class="line"><span class="lineno">  177</span>    <a class="code hl_struct" href="structthread__barrier__s.html">thread_barrier_t</a> b = *<a class="code hl_variable" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>;                          <span class="comment">// get the barrier pointer</span></div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">if</span> (b == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                           <span class="comment">// b is not created</span></div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">if</span> (b &amp;&amp; (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">magic</a> != <a class="code hl_define" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>)) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;    <span class="comment">// check that it is barrier (MAGIC)</span></div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                                   <span class="comment">// get the ownership</span></div>
<div class="line"><span class="lineno">  183</span>    b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a>++;                                           <span class="comment">// the current thread is the newcomer</span></div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">if</span> (b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a> == b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">expected</a>) {                        <span class="comment">// if all the expected threads are there</span></div>
<div class="line"><span class="lineno">  185</span>        <a class="code hl_define" href="list_8h.html#ad759a32561623ec6b31549db8276e8b6">list_foreach</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">wait</a>, waiting_item) {             <span class="comment">// then for each thread waiting</span></div>
<div class="line"><span class="lineno">  186</span>            <a class="code hl_function" href="list_8h.html#aab235aabe474279906a1958c9de03138">list_unlink</a> (waiting_item);                     <span class="comment">// get thread from waiting list</span></div>
<div class="line"><span class="lineno">  187</span>            <a class="code hl_struct" href="structthread__s.html">thread_t</a> t = <a class="code hl_function" href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item</a> (waiting_item);        <span class="comment">// get the pointer of a waiting thread</span></div>
<div class="line"><span class="lineno">  188</span>            <a class="code hl_function" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify</a> (t);                              <span class="comment">// and notifies it</span></div>
<div class="line"><span class="lineno">  189</span>        }</div>
<div class="line"><span class="lineno">  190</span>        b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">waiting</a> = 0;                                     <span class="comment">// init the counter of waiting threads</span></div>
<div class="line"><span class="lineno">  191</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                             <span class="comment">// release the ownership</span></div>
<div class="line"><span class="lineno">  192</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  193</span>        <a class="code hl_function" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">wait</a>, <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>);           <span class="comment">// the current thread in the wait. list</span></div>
<div class="line"><span class="lineno">  194</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;b-&gt;<a class="code hl_variable" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">lock</a>);                             <span class="comment">// release the lock</span></div>
<div class="line"><span class="lineno">  195</span>        <a class="code hl_function" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait</a> ();                                     <span class="comment">// tell the thread to wait</span></div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;                                         <span class="comment">// it&#39;s fine</span></div>
<div class="line"><span class="lineno">  199</span>}</div>
<div class="ttc" id="akthread_8c_html_a0c0fd0ef94a8688f65d53216ae6c33e7"><div class="ttname"><a href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait</a></div><div class="ttdeci">void thread_wait(void)</div><div class="ttdoc">Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...</div><div class="ttdef"><b>Definition:</b> kthread.c:403</div></div>
<div class="ttc" id="akthread_8c_html_a1da5431310f6068f6d1113c402eff5f8"><div class="ttname"><a href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a></div><div class="ttdeci">thread_t ThreadCurrent</div><div class="ttdoc">Pointeur to the current RUNNING thread (only one per processor) TODO should be an array if there are ...</div><div class="ttdef"><b>Definition:</b> kthread.c:54</div></div>
<div class="ttc" id="akthread_8c_html_a3ecc03b8319efabea835c1205c8fff4d"><div class="ttname"><a href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast</a></div><div class="ttdeci">void thread_addlast(list_t *root, thread_t thread)</div><div class="ttdef"><b>Definition:</b> kthread.c:56</div></div>
<div class="ttc" id="akthread_8c_html_a79b0f0a19a09db45e1689ff011f6109b"><div class="ttname"><a href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item</a></div><div class="ttdeci">thread_t thread_item(list_t *item)</div><div class="ttdef"><b>Definition:</b> kthread.c:61</div></div>
<div class="ttc" id="akthread_8c_html_acc9196e88e8db0daa5b13544cfe62996"><div class="ttname"><a href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify</a></div><div class="ttdeci">void thread_notify(thread_t thread)</div><div class="ttdoc">Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...</div><div class="ttdef"><b>Definition:</b> kthread.c:420</div></div>
<div class="ttc" id="alist_8h_html_aab235aabe474279906a1958c9de03138"><div class="ttname"><a href="list_8h.html#aab235aabe474279906a1958c9de03138">list_unlink</a></div><div class="ttdeci">static list_t * list_unlink(list_t *item)</div><div class="ttdoc">Unlink (i.e. detach) an item of list.</div><div class="ttdef"><b>Definition:</b> list.h:231</div></div>
<div class="ttc" id="alist_8h_html_ad759a32561623ec6b31549db8276e8b6"><div class="ttname"><a href="list_8h.html#ad759a32561623ec6b31549db8276e8b6">list_foreach</a></div><div class="ttdeci">#define list_foreach(ROOT, ITEM)</div><div class="ttdoc">C instruction to iterate through a list of items from first to last. list_foreach will iterate as man...</div><div class="ttdef"><b>Definition:</b> list.h:153</div></div>
<div class="ttc" id="astructthread__s_html"><div class="ttname"><a href="structthread__s.html">thread_s</a></div><div class="ttdoc">thread_s structure which contains all we need to define a thread the size of thread_s struct is a mul...</div><div class="ttdef"><b>Definition:</b> kthread.c:33</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="barrier_2main_8c.html#a779bfbbb688cf46720cfb65109ea4858">barrier</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="structthread__barrier__s.html#a49aeee62a81db234144e01be301540ef">thread_barrier_s::expected</a>, <a class="el" href="list_8h.html#ad759a32561623ec6b31549db8276e8b6">list_foreach</a>, <a class="el" href="list_8h.html#aab235aabe474279906a1958c9de03138">list_unlink()</a>, <a class="el" href="structthread__barrier__s.html#a8bbb69142ae57e50b5c83c31a8b00138">thread_barrier_s::lock</a>, <a class="el" href="structthread__barrier__s.html#a0ca24d9e62459d13238ea86bbb85c61c">thread_barrier_s::magic</a>, <a class="el" href="ksynchro_8c.html#a0841bee433f37156e826b327718b9db2">MAGIC_BARRIER</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast()</a>, <a class="el" href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item()</a>, <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify()</a>, <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait()</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, <a class="el" href="structthread__barrier__s.html#a64884bf0d1a1ef7f4a06521553e2e066">thread_barrier_s::wait</a>, and <a class="el" href="structthread__barrier__s.html#a2d4b05b20a64eb8536021d7a553c1de1">thread_barrier_s::waiting</a>.</p>

</div>
</div>
<a id="af85d5d2e4a36615955a7cfbae10eeec5" name="af85d5d2e4a36615955a7cfbae10eeec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85d5d2e4a36615955a7cfbae10eeec5">&#9670;&#160;</a></span>thread_mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroy the referenced mutex If the mutex is locked the destruction is not done, this is an error </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>a pointer referencing a mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on fealure</dd></dl>
<p>Destroy the given mutex if possible </p>
<div class="fragment"><div class="line"><span class="lineno">   47</span>{</div>
<div class="line"><span class="lineno">   48</span>    <a class="code hl_struct" href="structthread__mutex__s.html">thread_mutex_t</a> m = *mutex;</div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">if</span> (m == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                               <span class="comment">// unitialized mutex</span></div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>;                                  <span class="comment">// try to destroy an lock mutex</span></div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> != <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267">EPERM</a>;                <span class="comment">// the thread does not own the mutex</span></div>
<div class="line"><span class="lineno">   52</span>    <a class="code hl_function" href="kmemory_8c.html#a64c1f767a18f26f8c8cabd0f82f3e04d">kfree</a> (m, <span class="keyword">sizeof</span> (*m));</div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">   54</span>}</div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267">EPERM</a></div><div class="ttdeci">@ EPERM</div><div class="ttdef"><b>Definition:</b> errno.h:52</div></div>
<div class="ttc" id="astructthread__mutex__s_html"><div class="ttname"><a href="structthread__mutex__s.html">thread_mutex_s</a></div><div class="ttdef"><b>Definition:</b> ksynchro.c:21</div></div>
<div class="ttc" id="astructthread__mutex__s_html_a8755c9b956e9b431348fe2a47957246d"><div class="ttname"><a href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">thread_mutex_s::busy</a></div><div class="ttdeci">unsigned busy</div><div class="ttdoc">1 mutex is busy ; 0 mutex is free</div><div class="ttdef"><b>Definition:</b> ksynchro.c:23</div></div>
<div class="ttc" id="astructthread__mutex__s_html_aebfefcc73771f614b7f19296a46e2b04"><div class="ttname"><a href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">thread_mutex_s::owner</a></div><div class="ttdeci">thread_t owner</div><div class="ttdoc">a thread has to be locked and unlocked by the same thread</div><div class="ttdef"><b>Definition:</b> ksynchro.c:25</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">thread_mutex_s::busy</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b">EBUSY</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267">EPERM</a>, <a class="el" href="kmemory_8c.html#a64c1f767a18f26f8c8cabd0f82f3e04d">kfree()</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">thread_mutex_s::owner</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, and <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>.</p>

</div>
</div>
<a id="a2fbf4c52b56586ce18013333c7a1d37e" name="a2fbf4c52b56586ce18013333c7a1d37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbf4c52b56586ce18013333c7a1d37e">&#9670;&#160;</a></span>thread_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new mutex and initializes mutex variable with the new mutex (side effect) it is a nutex with error checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>a pointer referencing the new mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on fealure</dd></dl>
<p>Create and initialize a mutex </p>
<div class="fragment"><div class="line"><span class="lineno">   32</span>{</div>
<div class="line"><span class="lineno">   33</span>    <a class="code hl_struct" href="structthread__mutex__s.html">thread_mutex_t</a> m = <a class="code hl_function" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc</a> (<span class="keyword">sizeof</span> (*m));                   <span class="comment">// Get memory</span></div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">if</span> (m == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca">ENOMEM</a>;                               <span class="comment">// malloc impossible</span></div>
<div class="line"><span class="lineno">   35</span>    m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a> = 0;                                                <span class="comment">// lock to protect</span></div>
<div class="line"><span class="lineno">   36</span>    m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a> = 0;                                                <span class="comment">// busy is free at first</span></div>
<div class="line"><span class="lineno">   37</span>    <a class="code hl_function" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">wait</a>);                                       <span class="comment">// no waiting threads</span></div>
<div class="line"><span class="lineno">   38</span>    m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> = <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;                                            <span class="comment">// no thread owns the mutex</span></div>
<div class="line"><span class="lineno">   39</span>    *mutex = m;                                                 <span class="comment">// at last save the new mutex</span></div>
<div class="line"><span class="lineno">   40</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">   41</span>}</div>
<div class="ttc" id="astructthread__mutex__s_html_a541c29b3f7adb7366d0fa924fe212045"><div class="ttname"><a href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">thread_mutex_s::lock</a></div><div class="ttdeci">spinlock_t lock</div><div class="ttdoc">protection against parallel modifications</div><div class="ttdef"><b>Definition:</b> ksynchro.c:22</div></div>
<div class="ttc" id="astructthread__mutex__s_html_ad48ae2f605a85e11fa31e11c78cb726c"><div class="ttname"><a href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">thread_mutex_s::wait</a></div><div class="ttdeci">list_t wait</div><div class="ttdoc">list element to chain threads that are wainting for the mutex</div><div class="ttdef"><b>Definition:</b> ksynchro.c:24</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">thread_mutex_s::busy</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca">ENOMEM</a>, <a class="el" href="kmemory_8c.html#a87d8585002a620e687d68b38ab387a0e">kmalloc()</a>, <a class="el" href="list_8h.html#a4988c174e6ecc55436d5f0e3dbbb3980">list_init()</a>, <a class="el" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">thread_mutex_s::lock</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">thread_mutex_s::owner</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, and <a class="el" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">thread_mutex_s::wait</a>.</p>

</div>
</div>
<a id="aa5d516e2832e4c1f4d222a79fabe76a2" name="aa5d516e2832e4c1f4d222a79fabe76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d516e2832e4c1f4d222a79fabe76a2">&#9670;&#160;</a></span>thread_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lock the referenced mutex, it is a blocking operation. If the mutex is already locked, the calling thread blocks until the mutex becomes available. If the mutex does not exist or is already locked, this is an error </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>a pointer referencing a mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on fealure</dd></dl>
<p>lock = Acquire the mutex. First, check if the arguments are legal, then take the lock that protects the mutex, it is an active loop but not too long. After that, there are two possibilities: A) the mutex is busy, B) the mutex is free. A) busy case: ThreadCurrent is added to the end of the mutex's pending thread list using <a class="el" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast()</a>. This function is defined in the thread API (<a class="el" href="kthread_8c.html">kthread.c</a>), note that we cannot use <a class="el" href="list_8h.html#a116cfa18214dd2f855cff842bb14ca8f" title="Add a new added item before the current item which is root the most often. then the added item is pla...">list_addlast()</a> as we do not have access to the thread structure (it is a hidden structure for security reasons). Next, we need to release the lock, then finally the current thread needs to change its state from RUNNING to WAIT. When the thread that currently owns the mutex releases it, then it will give ownership of the mutex by leaving the state occupied, but changing the owner field. Note that it is possible that the release of the mutex occurs just after the current thread has decided to wait, there could be a risk that it will start waiting while it owns the mutex. This case is handled by the <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> and <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> functions, details are in the comments of these functions in <a class="el" href="kthread_8c.html">kthread.c</a>. B) free case : it's quite simple, it just have to set busy to 1 and fill the ownership field, and release the lock. </p>
<div class="fragment"><div class="line"><span class="lineno">   76</span>{</div>
<div class="line"><span class="lineno">   77</span>    <a class="code hl_struct" href="structthread__mutex__s.html">thread_mutex_t</a> m = *mutex;</div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">if</span> (m == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                           <span class="comment">// unitialized mutex</span></div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a> &amp;&amp; (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> == <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>)) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4354eedf02712f4da46f9d2d93d0b7ba">EDEADLK</a>; <span class="comment">// try to lock several times</span></div>
<div class="line"><span class="lineno">   80</span> </div>
<div class="line"><span class="lineno">   81</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a>);                                   <span class="comment">// take the lock of the mutex</span></div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a>) {                                          <span class="comment">// if the mutex is busy</span></div>
<div class="line"><span class="lineno">   83</span>        <a class="code hl_function" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">wait</a>, <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>);           <span class="comment">// put the current thread waiting</span></div>
<div class="line"><span class="lineno">   84</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a>);                             <span class="comment">// give the lock back</span></div>
<div class="line"><span class="lineno">   85</span>        <a class="code hl_function" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait</a> ();                                     <span class="comment">// tell the thread to wait</span></div>
<div class="line"><span class="lineno">   86</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   87</span>        m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a> = 1;                                        <span class="comment">// take the mutex</span></div>
<div class="line"><span class="lineno">   88</span>        m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> = <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>;                           <span class="comment">// set the ownership</span></div>
<div class="line"><span class="lineno">   89</span>        <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a>);                             <span class="comment">// give the lock back</span></div>
<div class="line"><span class="lineno">   90</span>    }</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;                                         <span class="comment">// and return with success</span></div>
<div class="line"><span class="lineno">   92</span>}</div>
<div class="ttc" id="aerrno_8h_html_a447416ba79b4777e7accabf3a8163cb3a4354eedf02712f4da46f9d2d93d0b7ba"><div class="ttname"><a href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4354eedf02712f4da46f9d2d93d0b7ba">EDEADLK</a></div><div class="ttdeci">@ EDEADLK</div><div class="ttdef"><b>Definition:</b> errno.h:39</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">thread_mutex_s::busy</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a4354eedf02712f4da46f9d2d93d0b7ba">EDEADLK</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">thread_mutex_s::lock</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">thread_mutex_s::owner</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8c.html#a3ecc03b8319efabea835c1205c8fff4d">thread_addlast()</a>, <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7">thread_wait()</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, and <a class="el" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">thread_mutex_s::wait</a>.</p>

</div>
</div>
<a id="ad515bf71cd806fc2d1a5c4143aca3988" name="ad515bf71cd806fc2d1a5c4143aca3988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad515bf71cd806fc2d1a5c4143aca3988">&#9670;&#160;</a></span>thread_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ksynchro_8h.html#ae7e296fd691b7e81249a311441936f79">thread_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unlock the referenced mutex If the mutex does not exist or is not locked or has been locked by another, this is an error that causes exit with error </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>a pointer referencing a mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on fealure</dd></dl>
<p>unlock : release the mutex First, check if the arguments are legal, then take the lock that protects the mutex, Then, get the thread in the thread waiting list of the mutex. There are two possibilities: A) there is one or B) there is not. A) There is a waiting thread, leave the busy field set to 1, change the property and notify the waiting thread with <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a> and it will become READY. If the new mutex owner decide to wait while the current thread try to notify it, there could be a risk that the new mutex owner waits definitively with the mutex ownership. This case is handled by the functions <a class="el" href="kthread_8c.html#a0c0fd0ef94a8688f65d53216ae6c33e7" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_wait()</a> and <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996" title="Ask the current RUNNING thread to WAIT the current thread must become READY again after the call to t...">thread_notify()</a>, see details in <a class="el" href="kthread_8c.html">kthread.c</a> B) There is no waiting thread, reset busy and owner. At last, in both cases, the mutex lock is released. </p>
<div class="fragment"><div class="line"><span class="lineno">  108</span>{</div>
<div class="line"><span class="lineno">  109</span>    <a class="code hl_struct" href="structthread__mutex__s.html">thread_mutex_t</a> m = *mutex;</div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">if</span> (m == <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                           <span class="comment">// unitialized mutex</span></div>
<div class="line"><span class="lineno">  111</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a> == 0) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>;                        <span class="comment">// unlocked an unlock mutex</span></div>
<div class="line"><span class="lineno">  112</span>    <span class="keywordflow">if</span> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> != <a class="code hl_variable" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>) <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267">EPERM</a>;            <span class="comment">// the thread does not own the mutex</span></div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>    <a class="code hl_function" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a>);                                   <span class="comment">// take the lock of the mutex</span></div>
<div class="line"><span class="lineno">  115</span>    <a class="code hl_struct" href="structlist__s.html">list_t</a> * waiting_item = <a class="code hl_function" href="list_8h.html#a240cff8d63cc4081b10fb6e25a374a8d">list_getfirst</a>(&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">wait</a>);        <span class="comment">// get thread from waiting list</span></div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">if</span> (waiting_item) {                                     <span class="comment">// if there is a thread waiting</span></div>
<div class="line"><span class="lineno">  117</span>        m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> = <a class="code hl_function" href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item</a> (waiting_item);              <span class="comment">// get the new mutex owner</span></div>
<div class="line"><span class="lineno">  118</span>        <a class="code hl_function" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify</a> (m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a>);                           <span class="comment">// this thread owns the mutex</span></div>
<div class="line"><span class="lineno">  119</span>    } <span class="keywordflow">else</span> {                                                <span class="comment">// no thread is waiting</span></div>
<div class="line"><span class="lineno">  120</span>        m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">busy</a> = 0;                                        <span class="comment">// free the mutex</span></div>
<div class="line"><span class="lineno">  121</span>        m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">owner</a> = <a class="code hl_define" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;                                    <span class="comment">// delete the owner field</span></div>
<div class="line"><span class="lineno">  122</span>    }</div>
<div class="line"><span class="lineno">  123</span>    <a class="code hl_function" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock</a> (&amp;m-&gt;<a class="code hl_variable" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">lock</a>);                                 <span class="comment">// give the lock back</span></div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>;</div>
<div class="line"><span class="lineno">  125</span>}</div>
<div class="ttc" id="alist_8h_html_a240cff8d63cc4081b10fb6e25a374a8d"><div class="ttname"><a href="list_8h.html#a240cff8d63cc4081b10fb6e25a374a8d">list_getfirst</a></div><div class="ttdeci">static list_t * list_getfirst(list_t *root)</div><div class="ttdoc">Unlink (i.e. detach) the first item of list.</div><div class="ttdef"><b>Definition:</b> list.h:242</div></div>
<div class="ttc" id="astructlist__s_html"><div class="ttname"><a href="structlist__s.html">list_s</a></div><div class="ttdoc">The 2-pointers structure to embed in the root of a list and in each of its items.</div><div class="ttdef"><b>Definition:</b> list.h:81</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="structthread__mutex__s.html#a8755c9b956e9b431348fe2a47957246d">thread_mutex_s::busy</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8">EINVAL</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267">EPERM</a>, <a class="el" href="list_8h.html#a240cff8d63cc4081b10fb6e25a374a8d">list_getfirst()</a>, <a class="el" href="structthread__mutex__s.html#a541c29b3f7adb7366d0fa924fe212045">thread_mutex_s::lock</a>, <a class="el" href="kfs_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="structthread__mutex__s.html#aebfefcc73771f614b7f19296a46e2b04">thread_mutex_s::owner</a>, <a class="el" href="atomic_8h.html#a92a25e1136e165cc5472d68e3901e364">spin_lock()</a>, <a class="el" href="atomic_8h.html#a73864b9b10141e82915121078d853a9e">spin_unlock()</a>, <a class="el" href="errno_8h.html#a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>, <a class="el" href="kthread_8c.html#a79b0f0a19a09db45e1689ff011f6109b">thread_item()</a>, <a class="el" href="kthread_8c.html#acc9196e88e8db0daa5b13544cfe62996">thread_notify()</a>, <a class="el" href="kthread_8c.html#a1da5431310f6068f6d1113c402eff5f8">ThreadCurrent</a>, and <a class="el" href="structthread__mutex__s.html#ad48ae2f605a85e11fa31e11c78cb726c">thread_mutex_s::wait</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
