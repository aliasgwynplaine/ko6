\hypertarget{ksynchro_8h}{\section{/users/enseig/franck/ko6/src/soft/kernel/ksynchro.h File Reference}
\label{ksynchro_8h}\index{/users/enseig/franck/ko6/src/soft/kernel/ksynchro.\-h@{/users/enseig/franck/ko6/src/soft/kernel/ksynchro.\-h}}
}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structthread__mutex__s}{thread\-\_\-mutex\-\_\-s} $\ast$ \hyperlink{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{thread\-\_\-mutex\-\_\-t}
\begin{DoxyCompactList}\small\item\em hidden mutex type, the other modules do not what is in the mutex structure \end{DoxyCompactList}\item 
typedef struct \hyperlink{structthread__barrier__s}{thread\-\_\-barrier\-\_\-s} $\ast$ \hyperlink{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}{thread\-\_\-barrier\-\_\-t}
\begin{DoxyCompactList}\small\item\em hidden barrier type, the user do not what is in the barrier structure \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{ksynchro_8h_a2fbf4c52b56586ce18013333c7a1d37e}{thread\-\_\-mutex\-\_\-init} (\hyperlink{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{thread\-\_\-mutex\-\_\-t} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em creates a new mutex and initializes mutex variable with the new mutex (side effect) it is a nutex with error checking \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_af85d5d2e4a36615955a7cfbae10eeec5}{thread\-\_\-mutex\-\_\-destroy} (\hyperlink{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{thread\-\_\-mutex\-\_\-t} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em destroy the referenced mutex If the mutex is locked the destruction is not done, this is an error \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_aa5d516e2832e4c1f4d222a79fabe76a2}{thread\-\_\-mutex\-\_\-lock} (\hyperlink{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{thread\-\_\-mutex\-\_\-t} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em lock the referenced mutex, it is a blocking operation. If the mutex is already locked, the calling thread blocks until the mutex becomes available. If the mutex does not exist or is already locked, this is an error \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_ad515bf71cd806fc2d1a5c4143aca3988}{thread\-\_\-mutex\-\_\-unlock} (\hyperlink{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{thread\-\_\-mutex\-\_\-t} $\ast$mutex)
\begin{DoxyCompactList}\small\item\em unlock the referenced mutex If the mutex does not exist or is not locked or has been locked by another, this is an error that causes exit with error \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_adea6885b17fdfc05ad0414fbaa41dd89}{thread\-\_\-barrier\-\_\-init} (\hyperlink{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}{thread\-\_\-barrier\-\_\-t} $\ast$\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier}, size\-\_\-t count)
\begin{DoxyCompactList}\small\item\em creates or initialize a barrier depending the value of barrier parameter \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_aea6f07b8093fabd5e248aae8b7e64abb}{thread\-\_\-barrier\-\_\-wait} (\hyperlink{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}{thread\-\_\-barrier\-\_\-t} $\ast$\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier})
\begin{DoxyCompactList}\small\item\em wait to the referenced barrier, it is a blocking operation for all thread but the last the last arrived thread doesn't wait and notifies the other threads which becomes R\-E\-A\-D\-Y \end{DoxyCompactList}\item 
int \hyperlink{ksynchro_8h_a384a3caafcd4e7c672a583fc4183f983}{thread\-\_\-barrier\-\_\-destroy} (\hyperlink{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}{thread\-\_\-barrier\-\_\-t} $\ast$\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier})
\begin{DoxyCompactList}\small\item\em destroy the referenced barrier If a thread is waiting at the barrier, then the destruction is not done, it is an error \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\hypertarget{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-barrier\-\_\-t@{thread\-\_\-barrier\-\_\-t}}
\index{thread\-\_\-barrier\-\_\-t@{thread\-\_\-barrier\-\_\-t}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-barrier\-\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf thread\-\_\-barrier\-\_\-s}$\ast$ {\bf thread\-\_\-barrier\-\_\-t}}}\label{ksynchro_8h_a130bec7a93458fc744ffe3d6b7c85e8c}


hidden barrier type, the user do not what is in the barrier structure 

\hypertarget{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-mutex\-\_\-t@{thread\-\_\-mutex\-\_\-t}}
\index{thread\-\_\-mutex\-\_\-t@{thread\-\_\-mutex\-\_\-t}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-mutex\-\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf thread\-\_\-mutex\-\_\-s}$\ast$ {\bf thread\-\_\-mutex\-\_\-t}}}\label{ksynchro_8h_ae7e296fd691b7e81249a311441936f79}


hidden mutex type, the other modules do not what is in the mutex structure 



\subsection{Function Documentation}
\hypertarget{ksynchro_8h_a384a3caafcd4e7c672a583fc4183f983}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-barrier\-\_\-destroy@{thread\-\_\-barrier\-\_\-destroy}}
\index{thread\-\_\-barrier\-\_\-destroy@{thread\-\_\-barrier\-\_\-destroy}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-barrier\-\_\-destroy}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-barrier\-\_\-destroy (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-barrier\-\_\-t} $\ast$}]{barrier}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_a384a3caafcd4e7c672a583fc4183f983}


destroy the referenced barrier If a thread is waiting at the barrier, then the destruction is not done, it is an error 


\begin{DoxyParams}{Parameters}
{\em barrier} & a pointer referencing a barrier \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\-U\-C\-C\-E\-S\-S if it all goes fine or E\-I\-N\-V\-A\-L wrong argument E\-B\-U\-S\-Y The implementation has detected an attempt to destroy a barrier while it is in use (for example, while being used in a \hyperlink{ksynchro_8c_aea6f07b8093fabd5e248aae8b7e64abb}{thread\-\_\-barrier\-\_\-wait()} call) by another thread. 
\end{DoxyReturn}


References barrier, E\-B\-U\-S\-Y, E\-I\-N\-V\-A\-L, kfree(), thread\-\_\-barrier\-\_\-s\-::lock, thread\-\_\-barrier\-\_\-s\-::magic, M\-A\-G\-I\-C\-\_\-\-B\-A\-R\-R\-I\-E\-R, N\-U\-L\-L, spin\-\_\-lock, spin\-\_\-unlock, S\-U\-C\-C\-E\-S\-S, and thread\-\_\-barrier\-\_\-s\-::waiting.


\begin{DoxyCode}
202 \{
203     \hyperlink{structthread__barrier__s}{thread\_barrier\_t} b = *\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier};                          \textcolor{comment}{// get the barrier
       pointer}
204 
205     \textcolor{keywordflow}{if} (b == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                           \textcolor{comment}{// b is not created}
206     \textcolor{keywordflow}{if} (b && (b->\hyperlink{structthread__barrier__s_a0ca24d9e62459d13238ea86bbb85c61c}{magic} != \hyperlink{ksynchro_8c_a0841bee433f37156e826b327718b9db2}{MAGIC\_BARRIER})) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};    \textcolor{comment}{// check that it is
       barrier (MAGIC)}
207 
208     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                                   \textcolor{comment}{// get the ownership}
209     \textcolor{keywordflow}{if} (b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting} != 0) \{                                  \textcolor{comment}{// if barrier is in use}
210         \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                             \textcolor{comment}{// release the lock}
211         \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b}{EBUSY};                                       \textcolor{comment}{// return an error}
212     \}
213     \hyperlink{kmemory_8c_a64c1f767a18f26f8c8cabd0f82f3e04d}{kfree} (b, \textcolor{keyword}{sizeof} (\textcolor{keyword}{struct} \hyperlink{structthread__barrier__s}{thread\_barrier\_s}));            \textcolor{comment}{// destroys barrier &
       erases its memory}
214 
215     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};                                         \textcolor{comment}{// erasing the memory releases the lock}
216 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_adea6885b17fdfc05ad0414fbaa41dd89}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-barrier\-\_\-init@{thread\-\_\-barrier\-\_\-init}}
\index{thread\-\_\-barrier\-\_\-init@{thread\-\_\-barrier\-\_\-init}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-barrier\-\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-barrier\-\_\-init (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-barrier\-\_\-t} $\ast$}]{barrier, }
\item[{size\-\_\-t}]{count}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_adea6885b17fdfc05ad0414fbaa41dd89}


creates or initialize a barrier depending the value of barrier parameter 


\begin{DoxyParams}{Parameters}
{\em barrier} & a pointer referencing the barrier, there are two cases 1) if $\ast$barrier == N\-U\-L\-L then allocate a new barrier, then initialize count 2) if $\ast$barrier != N\-U\-L\-L it the barrier already exists, just initialize count \\
\hline
{\em count} & number of expected threads for this barrier \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\-U\-C\-C\-E\-S\-S if it all goes fine or E\-I\-N\-V\-A\-L barrier is not a barrier or the value specified by count is equal to zero. E\-N\-O\-M\-E\-M Insufficient memory exists to initialize the barrier E\-B\-U\-S\-Y The implementation has detected an attempt to reinitialize a barrier while it is in use (for example, while being used in a \hyperlink{ksynchro_8c_aea6f07b8093fabd5e248aae8b7e64abb}{thread\-\_\-barrier\-\_\-wait()} call) by another thread. 
\end{DoxyReturn}


References barrier, E\-B\-U\-S\-Y, E\-I\-N\-V\-A\-L, E\-N\-O\-M\-E\-M, thread\-\_\-barrier\-\_\-s\-::expected, kmalloc(), list\-\_\-init(), thread\-\_\-barrier\-\_\-s\-::lock, thread\-\_\-barrier\-\_\-s\-::magic, M\-A\-G\-I\-C\-\_\-\-B\-A\-R\-R\-I\-E\-R, N\-U\-L\-L, spin\-\_\-lock, S\-U\-C\-C\-E\-S\-S, thread\-\_\-barrier\-\_\-s\-::wait, and thread\-\_\-barrier\-\_\-s\-::waiting.


\begin{DoxyCode}
144 \{
145     \hyperlink{structthread__barrier__s}{thread\_barrier\_t} b = *\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier};                          \textcolor{comment}{// get the barrier
       pointer}
146 
147     \textcolor{keywordflow}{if} (count == 0) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                          \textcolor{comment}{// count must be > 0}
148 
149     \textcolor{keywordflow}{if} (b == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \{                                        \textcolor{comment}{// if we need a new barrier}
150         b = \hyperlink{kmemory_8c_a5f52d7c56b7d67dc2f96b2e93dfdc7be}{kmalloc} (\textcolor{keyword}{sizeof} (\textcolor{keyword}{struct} \hyperlink{structthread__barrier__s}{thread\_barrier\_s}));     \textcolor{comment}{// allocates a new
       barrier}
151         \textcolor{keywordflow}{if} (b == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca}{ENOMEM};                       \textcolor{comment}{// test if there is enough memory}
152         b->\hyperlink{structthread__barrier__s_a0ca24d9e62459d13238ea86bbb85c61c}{magic} = \hyperlink{ksynchro_8c_a0841bee433f37156e826b327718b9db2}{MAGIC\_BARRIER};                           \textcolor{comment}{// tell it is a BARRIER}
153         b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock} = 0;                                        \textcolor{comment}{// free the lock}
154         b->\hyperlink{structthread__barrier__s_a49aeee62a81db234144e01be301540ef}{expected} = count;                                \textcolor{comment}{// init the expected threads}
155         b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting} = 0;                                     \textcolor{comment}{// init the counter of waiting threads}
156         \hyperlink{list_8h_a4988c174e6ecc55436d5f0e3dbbb3980}{list\_init} (&b->\hyperlink{structthread__barrier__s_a64884bf0d1a1ef7f4a06521553e2e066}{wait});                               \textcolor{comment}{// init the waiting list}
157         *barrier = b;                                       \textcolor{comment}{// at last, init. the return variable}
158         \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};                                     \textcolor{comment}{// it's fine}
159     \}
160 
161     \textcolor{keywordflow}{if} (b && (b->\hyperlink{structthread__barrier__s_a0ca24d9e62459d13238ea86bbb85c61c}{magic} != \hyperlink{ksynchro_8c_a0841bee433f37156e826b327718b9db2}{MAGIC\_BARRIER})) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};    \textcolor{comment}{// it is not an old
       barrier}
162 
163     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                                   \textcolor{comment}{// get the ownership}
164     \textcolor{keywordflow}{if} (b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting} != 0) \{                                  \textcolor{comment}{// if someone is waiting}
165         \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                               \textcolor{comment}{// release the ownership}
166         \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b}{EBUSY};                                       \textcolor{comment}{// return an error}
167     \}
168 
169     b->\hyperlink{structthread__barrier__s_a49aeee62a81db234144e01be301540ef}{expected} = count;                                    \textcolor{comment}{// set the number of expected threads}
170     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                                   \textcolor{comment}{// release the ownership}
171 
172     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};                                         \textcolor{comment}{// it's fine}
173 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_aea6f07b8093fabd5e248aae8b7e64abb}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-barrier\-\_\-wait@{thread\-\_\-barrier\-\_\-wait}}
\index{thread\-\_\-barrier\-\_\-wait@{thread\-\_\-barrier\-\_\-wait}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-barrier\-\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-barrier\-\_\-wait (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-barrier\-\_\-t} $\ast$}]{barrier}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_aea6f07b8093fabd5e248aae8b7e64abb}


wait to the referenced barrier, it is a blocking operation for all thread but the last the last arrived thread doesn't wait and notifies the other threads which becomes R\-E\-A\-D\-Y 


\begin{DoxyParams}{Parameters}
{\em barrier} & a pointer referencing a barrier \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\-U\-C\-C\-E\-S\-S or F\-E\-A\-L\-U\-R\-E 
\end{DoxyReturn}


References barrier, E\-I\-N\-V\-A\-L, thread\-\_\-barrier\-\_\-s\-::expected, list\-\_\-foreach, list\-\_\-unlink(), thread\-\_\-barrier\-\_\-s\-::lock, thread\-\_\-barrier\-\_\-s\-::magic, M\-A\-G\-I\-C\-\_\-\-B\-A\-R\-R\-I\-E\-R, N\-U\-L\-L, spin\-\_\-lock, spin\-\_\-unlock, S\-U\-C\-C\-E\-S\-S, thread\-\_\-addlast(), thread\-\_\-item(), thread\-\_\-notify(), thread\-\_\-wait(), Thread\-Current, thread\-\_\-barrier\-\_\-s\-::wait, and thread\-\_\-barrier\-\_\-s\-::waiting.


\begin{DoxyCode}
176 \{
177     \hyperlink{structthread__barrier__s}{thread\_barrier\_t} b = *\hyperlink{barrier_2main_8c_a779bfbbb688cf46720cfb65109ea4858}{barrier};                          \textcolor{comment}{// get the barrier
       pointer}
178 
179     \textcolor{keywordflow}{if} (b == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                           \textcolor{comment}{// b is not created}
180     \textcolor{keywordflow}{if} (b && (b->\hyperlink{structthread__barrier__s_a0ca24d9e62459d13238ea86bbb85c61c}{magic} != \hyperlink{ksynchro_8c_a0841bee433f37156e826b327718b9db2}{MAGIC\_BARRIER})) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};    \textcolor{comment}{// check that it is
       barrier (MAGIC)}
181 
182     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                                   \textcolor{comment}{// get the ownership}
183     b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting}++;                                           \textcolor{comment}{// the current thread is the newcomer}
184     \textcolor{keywordflow}{if} (b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting} == b->\hyperlink{structthread__barrier__s_a49aeee62a81db234144e01be301540ef}{expected}) \{                        \textcolor{comment}{// if all the expected threads
       are there}
185         \hyperlink{list_8h_ad759a32561623ec6b31549db8276e8b6}{list\_foreach} (&b->\hyperlink{structthread__barrier__s_a64884bf0d1a1ef7f4a06521553e2e066}{wait}, waiting\_item) \{             \textcolor{comment}{// then for each thread waiting}
186             \hyperlink{list_8h_ac68d25438cd5f3cc2e5b04dbf174bf27}{list\_unlink} (waiting\_item);                     \textcolor{comment}{// get thread from waiting list}
187             \hyperlink{structthread__s}{thread\_t} t = \hyperlink{kthread_8c_a79b0f0a19a09db45e1689ff011f6109b}{thread\_item} (waiting\_item);        \textcolor{comment}{// get the pointer of a
       waiting thread}
188             \hyperlink{kthread_8c_acc9196e88e8db0daa5b13544cfe62996}{thread\_notify} (t);                              \textcolor{comment}{// and notifies it}
189         \}
190         b->\hyperlink{structthread__barrier__s_a2d4b05b20a64eb8536021d7a553c1de1}{waiting} = 0;                                     \textcolor{comment}{// init the counter of waiting threads}
191         \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                             \textcolor{comment}{// release the ownership}
192     \} \textcolor{keywordflow}{else} \{
193         \hyperlink{kthread_8c_a3ecc03b8319efabea835c1205c8fff4d}{thread\_addlast} (&b->\hyperlink{structthread__barrier__s_a64884bf0d1a1ef7f4a06521553e2e066}{wait}, \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent});           \textcolor{comment}{// the current
       thread in the wait. list}
194         \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&b->\hyperlink{structthread__barrier__s_a8bbb69142ae57e50b5c83c31a8b00138}{lock});                             \textcolor{comment}{// release the lock}
195         \hyperlink{kthread_8c_a0c0fd0ef94a8688f65d53216ae6c33e7}{thread\_wait} ();                                     \textcolor{comment}{// tell the thread to wait}
196     \}
197 
198     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};                                         \textcolor{comment}{// it's fine}
199 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_af85d5d2e4a36615955a7cfbae10eeec5}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-mutex\-\_\-destroy@{thread\-\_\-mutex\-\_\-destroy}}
\index{thread\-\_\-mutex\-\_\-destroy@{thread\-\_\-mutex\-\_\-destroy}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-mutex\-\_\-destroy}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-mutex\-\_\-destroy (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-mutex\-\_\-t} $\ast$}]{mutex}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_af85d5d2e4a36615955a7cfbae10eeec5}


destroy the referenced mutex If the mutex is locked the destruction is not done, this is an error 


\begin{DoxyParams}{Parameters}
{\em mutex} & a pointer referencing a mutex \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, 1 on fealure
\end{DoxyReturn}
Destroy the given mutex if possible 

References thread\-\_\-mutex\-\_\-s\-::busy, E\-B\-U\-S\-Y, E\-I\-N\-V\-A\-L, E\-P\-E\-R\-M, kfree(), N\-U\-L\-L, thread\-\_\-mutex\-\_\-s\-::owner, S\-U\-C\-C\-E\-S\-S, and Thread\-Current.


\begin{DoxyCode}
47 \{
48     \hyperlink{structthread__mutex__s}{thread\_mutex\_t} m = *mutex;
49     \textcolor{keywordflow}{if} (m == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                               \textcolor{comment}{// unitialized mutex}
50     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a9e2f813a51a5763a892f4b1783778e4b}{EBUSY};                                  \textcolor{comment}{// try to destroy an lock mutex}
51     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} != \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267}{EPERM};                \textcolor{comment}{// the thread does
       not own the mutex}
52     \hyperlink{kmemory_8c_a64c1f767a18f26f8c8cabd0f82f3e04d}{kfree} (m, \textcolor{keyword}{sizeof} (*m));
53     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};
54 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_a2fbf4c52b56586ce18013333c7a1d37e}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-mutex\-\_\-init@{thread\-\_\-mutex\-\_\-init}}
\index{thread\-\_\-mutex\-\_\-init@{thread\-\_\-mutex\-\_\-init}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-mutex\-\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-mutex\-\_\-init (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-mutex\-\_\-t} $\ast$}]{mutex}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_a2fbf4c52b56586ce18013333c7a1d37e}


creates a new mutex and initializes mutex variable with the new mutex (side effect) it is a nutex with error checking 


\begin{DoxyParams}{Parameters}
{\em mutex} & a pointer referencing the new mutex \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, 1 on fealure
\end{DoxyReturn}
Create and initialize a mutex 

References thread\-\_\-mutex\-\_\-s\-::busy, E\-N\-O\-M\-E\-M, kmalloc(), list\-\_\-init(), thread\-\_\-mutex\-\_\-s\-::lock, N\-U\-L\-L, thread\-\_\-mutex\-\_\-s\-::owner, S\-U\-C\-C\-E\-S\-S, and thread\-\_\-mutex\-\_\-s\-::wait.


\begin{DoxyCode}
32 \{
33     \hyperlink{structthread__mutex__s}{thread\_mutex\_t} m = \hyperlink{kmemory_8c_a5f52d7c56b7d67dc2f96b2e93dfdc7be}{kmalloc} (\textcolor{keyword}{sizeof} (*m));                   \textcolor{comment}{// Get memory}
34     \textcolor{keywordflow}{if} (m == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3aec0aa1bb79e2e55ed6d8c165e0611eca}{ENOMEM};                               \textcolor{comment}{// malloc impossible}
35     m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock} = 0;                                                \textcolor{comment}{// lock to protect}
36     m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy} = 0;                                                \textcolor{comment}{// busy is free at first}
37     \hyperlink{list_8h_a4988c174e6ecc55436d5f0e3dbbb3980}{list\_init} (&m->\hyperlink{structthread__mutex__s_ad48ae2f605a85e11fa31e11c78cb726c}{wait});                                       \textcolor{comment}{// no waiting threads}
38     m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} = \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};                                            \textcolor{comment}{// no thread owns the mutex}
39     *mutex = m;                                                 \textcolor{comment}{// at last save the new mutex}
40     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};
41 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_aa5d516e2832e4c1f4d222a79fabe76a2}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-mutex\-\_\-lock@{thread\-\_\-mutex\-\_\-lock}}
\index{thread\-\_\-mutex\-\_\-lock@{thread\-\_\-mutex\-\_\-lock}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-mutex\-\_\-lock}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-mutex\-\_\-lock (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-mutex\-\_\-t} $\ast$}]{mutex}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_aa5d516e2832e4c1f4d222a79fabe76a2}


lock the referenced mutex, it is a blocking operation. If the mutex is already locked, the calling thread blocks until the mutex becomes available. If the mutex does not exist or is already locked, this is an error 


\begin{DoxyParams}{Parameters}
{\em mutex} & a pointer referencing a mutex \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, 1 on fealure
\end{DoxyReturn}
lock = Acquire the mutex. First, check if the arguments are legal, then take the lock that protects the mutex, it is an active loop but not too long. After that, there are two possibilities\-: A) the mutex is busy, B) the mutex is free. A) busy case\-: Thread\-Current is added to the end of the mutex's pending thread list using \hyperlink{kthread_8c_a3ecc03b8319efabea835c1205c8fff4d}{thread\-\_\-addlast()}. This function is defined in the thread A\-P\-I (\hyperlink{kthread_8c}{kthread.\-c}), note that we cannot use \hyperlink{list_8h_a116cfa18214dd2f855cff842bb14ca8f}{list\-\_\-addlast()} as we do not have access to the thread structure (it is a hidden structure for security reasons). Next, we need to release the lock, then finally the current thread needs to change its state from R\-U\-N\-N\-I\-N\-G to W\-A\-I\-T. When the thread that currently owns the mutex releases it, then it will give ownership of the mutex by leaving the state occupied, but changing the owner field. Note that it is possible that the release of the mutex occurs just after the current thread has decided to wait, there could be a risk that it will start waiting while it owns the mutex. This case is handled by the \hyperlink{kthread_8c_a0c0fd0ef94a8688f65d53216ae6c33e7}{thread\-\_\-wait()} and \hyperlink{kthread_8c_acc9196e88e8db0daa5b13544cfe62996}{thread\-\_\-notify()} functions, details are in the comments of these functions in \hyperlink{kthread_8c}{kthread.\-c}. B) free case \-: it's quite simple, it just have to set busy to 1 and fill the ownership field, and release the lock. 

References thread\-\_\-mutex\-\_\-s\-::busy, E\-D\-E\-A\-D\-L\-K, E\-I\-N\-V\-A\-L, thread\-\_\-mutex\-\_\-s\-::lock, N\-U\-L\-L, thread\-\_\-mutex\-\_\-s\-::owner, spin\-\_\-lock, spin\-\_\-unlock, S\-U\-C\-C\-E\-S\-S, thread\-\_\-addlast(), thread\-\_\-wait(), Thread\-Current, and thread\-\_\-mutex\-\_\-s\-::wait.


\begin{DoxyCode}
76 \{
77     \hyperlink{structthread__mutex__s}{thread\_mutex\_t} m = *mutex;
78     \textcolor{keywordflow}{if} (m == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                           \textcolor{comment}{// unitialized mutex}
79     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy} && (m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} == \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent})) \textcolor{keywordflow}{return} 
      \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a4354eedf02712f4da46f9d2d93d0b7ba}{EDEADLK}; \textcolor{comment}{// try to lock several times}
80 
81     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock});                                   \textcolor{comment}{// take the lock of the mutex}
82     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy}) \{                                          \textcolor{comment}{// if the mutex is busy}
83         \hyperlink{kthread_8c_a3ecc03b8319efabea835c1205c8fff4d}{thread\_addlast} (&m->\hyperlink{structthread__mutex__s_ad48ae2f605a85e11fa31e11c78cb726c}{wait}, \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent});           \textcolor{comment}{// put the
       current thread waiting}
84         \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock});                             \textcolor{comment}{// give the lock back}
85         \hyperlink{kthread_8c_a0c0fd0ef94a8688f65d53216ae6c33e7}{thread\_wait} ();                                     \textcolor{comment}{// tell the thread to wait}
86     \} \textcolor{keywordflow}{else} \{
87         m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy} = 1;                                        \textcolor{comment}{// take the mutex}
88         m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} = \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent};                           \textcolor{comment}{// set the ownership}
89         \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock});                             \textcolor{comment}{// give the lock back}
90     \}
91     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};                                         \textcolor{comment}{// and return with success}
92 \}
\end{DoxyCode}
\hypertarget{ksynchro_8h_ad515bf71cd806fc2d1a5c4143aca3988}{\index{ksynchro.\-h@{ksynchro.\-h}!thread\-\_\-mutex\-\_\-unlock@{thread\-\_\-mutex\-\_\-unlock}}
\index{thread\-\_\-mutex\-\_\-unlock@{thread\-\_\-mutex\-\_\-unlock}!ksynchro.h@{ksynchro.\-h}}
\subsubsection[{thread\-\_\-mutex\-\_\-unlock}]{\setlength{\rightskip}{0pt plus 5cm}int thread\-\_\-mutex\-\_\-unlock (
\begin{DoxyParamCaption}
\item[{{\bf thread\-\_\-mutex\-\_\-t} $\ast$}]{mutex}
\end{DoxyParamCaption}
)}}\label{ksynchro_8h_ad515bf71cd806fc2d1a5c4143aca3988}


unlock the referenced mutex If the mutex does not exist or is not locked or has been locked by another, this is an error that causes exit with error 


\begin{DoxyParams}{Parameters}
{\em mutex} & a pointer referencing a mutex \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, 1 on fealure
\end{DoxyReturn}
unlock \-: release the mutex First, check if the arguments are legal, then take the lock that protects the mutex, Then, get the thread in the thread waiting list of the mutex. There are two possibilities\-: A) there is one or B) there is not. A) There is a waiting thread, leave the busy field set to 1, change the property and notify the waiting thread with \hyperlink{kthread_8c_acc9196e88e8db0daa5b13544cfe62996}{thread\-\_\-notify()} and it will become R\-E\-A\-D\-Y. If the new mutex owner decide to wait while the current thread try to notify it, there could be a risk that the new mutex owner waits definitively with the mutex ownership. This case is handled by the functions \hyperlink{kthread_8c_a0c0fd0ef94a8688f65d53216ae6c33e7}{thread\-\_\-wait()} and \hyperlink{kthread_8c_acc9196e88e8db0daa5b13544cfe62996}{thread\-\_\-notify()}, see details in \hyperlink{kthread_8c}{kthread.\-c} B) There is no waiting thread, reset busy and owner. At last, in both cases, the mutex lock is released. 

References thread\-\_\-mutex\-\_\-s\-::busy, E\-I\-N\-V\-A\-L, E\-P\-E\-R\-M, list\-\_\-getfirst(), thread\-\_\-mutex\-\_\-s\-::lock, N\-U\-L\-L, thread\-\_\-mutex\-\_\-s\-::owner, spin\-\_\-lock, spin\-\_\-unlock, S\-U\-C\-C\-E\-S\-S, thread\-\_\-item(), thread\-\_\-notify(), Thread\-Current, and thread\-\_\-mutex\-\_\-s\-::wait.


\begin{DoxyCode}
108 \{
109     \hyperlink{structthread__mutex__s}{thread\_mutex\_t} m = *mutex;
110     \textcolor{keywordflow}{if} (m == \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                           \textcolor{comment}{// unitialized mutex}
111     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy} == 0) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a7bfd237190819a0a272db7b0aa61d5c8}{EINVAL};                        \textcolor{comment}{// unlocked an unlock mutex}
112     \textcolor{keywordflow}{if} (m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} != \hyperlink{kthread_8c_a1da5431310f6068f6d1113c402eff5f8}{ThreadCurrent}) \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3a156dcc38d9ba0765c6150544963ed267}{EPERM};            \textcolor{comment}{// the thread does not
       own the mutex}
113 
114     \hyperlink{mips_2atomic_8S_abff7230a2ee820f538a2574ee5b3a593}{spin\_lock} (&m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock});                                   \textcolor{comment}{// take the lock of the mutex}
115     \hyperlink{structlist__s}{list\_t} * waiting\_item = \hyperlink{list_8h_a60162e4580a37bddf823ca73567011d8}{list\_getfirst}(&m->\hyperlink{structthread__mutex__s_ad48ae2f605a85e11fa31e11c78cb726c}{wait});        \textcolor{comment}{// get thread from
       waiting list}
116     \textcolor{keywordflow}{if} (waiting\_item) \{                                     \textcolor{comment}{// if there is a thread waiting}
117         m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} = \hyperlink{kthread_8c_a79b0f0a19a09db45e1689ff011f6109b}{thread\_item} (waiting\_item);              \textcolor{comment}{// get the new mutex owner}
118         \hyperlink{kthread_8c_acc9196e88e8db0daa5b13544cfe62996}{thread\_notify} (m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner});                           \textcolor{comment}{// this thread owns the mutex}
119     \} \textcolor{keywordflow}{else} \{                                                \textcolor{comment}{// no thread is waiting}
120         m->\hyperlink{structthread__mutex__s_a8755c9b956e9b431348fe2a47957246d}{busy} = 0;                                        \textcolor{comment}{// free the mutex}
121         m->\hyperlink{structthread__mutex__s_aebfefcc73771f614b7f19296a46e2b04}{owner} = \hyperlink{kfs_8c_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};                                    \textcolor{comment}{// delete the owner field}
122     \}
123     \hyperlink{mips_2atomic_8S_a18d39a883be260c78529672999549545}{spin\_unlock} (&m->\hyperlink{structthread__mutex__s_a541c29b3f7adb7366d0fa924fe212045}{lock});                                 \textcolor{comment}{// give the lock back}
124     \textcolor{keywordflow}{return} \hyperlink{errno_8h_a447416ba79b4777e7accabf3a8163cb3ac7f69f7c9e5aea9b8f54cf02870e2bf8}{SUCCESS};
125 \}
\end{DoxyCode}
